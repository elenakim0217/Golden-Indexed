<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Golden Indexed 2.0</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Nanum+Gothic+Coding:wght@700&family=Noto+Sans+KR:wght@700&display=swap" rel="stylesheet">

    <style>
        /* 1. Wanted Sans 폰트 추가 (정보 팝업용) */
        @import url('https://cdn.jsdelivr.net/gh/wanteddev/wanted-sans@v1.0.1/packages/wanted-sans/fonts/webfonts/variable/split/WantedSansVariable.min.css');

        /* 기본 설정 */
        body {
            margin: 0;
            padding: 0;
            background-color: black;
            min-height: 100vh;
            width: 100vw;
            /* 기존 폰트 유지: 영문도 Nanum Gothic Coding으로 출력됨 */
            font-family: 'Nanum Gothic Coding', 'Noto Sans KR', monospace;
            font-weight: 700;
            overflow: hidden; 
            user-select: none; 
        }

        /* 배경 아트워크 (z-index 0) */
        #canvas-container {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 0; pointer-events: none;
        }
        .art-shape {
            stroke: rgba(255, 255, 255, 0.5); 
            stroke-width: 1px; fill: none; will-change: transform;
        }

        /* NASA 이미지 레이어 (z-index 20) */
        #nasa-image-layer {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 20; pointer-events: none;
        }
        .nasa-popup-img {
            position: absolute; width: 7.5vw; max-height: 15vh;
            object-fit: contain; opacity: 0;
            pointer-events: auto; cursor: grab;
            filter: grayscale(40%) contrast(1.2) brightness(0.8);
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.3); 
            animation: scanEffect 1.5s cubic-bezier(0.1, 0.9, 0.2, 1) forwards, floatSpace 6s ease-in-out infinite alternate;
            transition: opacity 1s ease-in-out;
        }
        .nasa-popup-img:active {
            cursor: grabbing; filter: brightness(1.3) contrast(1.3) drop-shadow(0 0 10px white);
            animation: none; z-index: 1000;
        }

        /* 애니메이션 키프레임 */
        @keyframes scanEffect {
            0% { opacity: 0; clip-path: inset(100% 0 0 0); transform: translateY(30px) scale(0.9); filter: brightness(2) contrast(2) hue-rotate(90deg); }
            10% { opacity: 1; clip-path: inset(80% 0 0 0); }
            20% { clip-path: inset(40% 0 20% 0); filter: brightness(1.5) hue-rotate(-45deg); }
            40% { clip-path: inset(20% 0 0 0); transform: translateY(10px) scale(0.95); }
            60% { filter: brightness(1.2) sepia(1); }
            100% { opacity: 0.8; clip-path: inset(0 0 0 0); transform: translateY(0) scale(1); filter: grayscale(20%) contrast(1.1); }
        }
        @keyframes floatSpace {
            0% { margin-top: 0px; margin-left: 0px; }
            100% { margin-top: -20px; margin-left: 10px; }
        }
        .fade-out {
            opacity: 0 !important; transform: scale(0.8) translateY(-20px) !important; filter: blur(10px) !important;
            transition: opacity 1s ease-out, transform 1s ease-in; pointer-events: none;
        }
        .sucked-in {
            transition: all 0.5s cubic-bezier(0.5, 0, 1, 1) !important; opacity: 0 !important;
            transform: scale(0) rotate(720deg) !important; filter: brightness(2) !important;
        }

        /* 오디오 비주얼라이저 (z-index 5) */
        #visualizer-layer {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 5; pointer-events: none; 
            display: flex; align-items: center; justify-content: center;
        }
        canvas#oscilloscope { width: 100%; height: 100%; }

        /* 시작 버튼 */
        #startBtn {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            z-index: 30; padding: 15px 30px;
            font-family: 'Nanum Gothic Coding', monospace; font-size: 16px; font-weight: bold;
            color: #FFFF00; background-color: rgba(0, 0, 0, 0.8);
            border: 1px solid #FFFF00; border-radius: 50px;
            cursor: pointer; transition: all 0.3s;
        }
        #startBtn:hover { background-color: #ffffff; color: black; }

        /* 메시지 로그 & 입력창 (z-index 15) */
        #content-layer {
            position: relative; z-index: 15; 
            width: 100%; min-height: 100vh;
            box-sizing: border-box; padding: 40px;
            display: flex; flex-direction: column; justify-content: flex-end;
            pointer-events: none; 
        }
        #messageLog, #input-wrapper { pointer-events: auto; }
        #messageLog { width: 100%; display: flex; flex-direction: column; justify-content: flex-end; margin-bottom: 30px; }
        .message-entry { display: flex; flex-direction: row; margin-bottom: 20px; font-size: 16px; line-height: 1.6; color: #FFFFF0; }
        .binary-date { font-family: 'Nanum Gothic Coding', monospace; white-space: nowrap; margin-right: 25px; color: #FFFFF0; opacity: 0.9; font-size: 14px; line-height: 1.8; }
        .message-text { font-family: 'Nanum Gothic Coding', monospace; word-break: break-all; color: #FFFFF0; font-size: 18px; }
        #input-wrapper { display: flex; flex-direction: row; align-items: center; width: 100%; padding-top: 10px; border-top: 1px solid rgba(255, 255, 255, 0.2); }
        #blinking-cursor { font-family: 'Nanum Gothic Coding', monospace; font-size: 18px; color: #FFFFF0; margin-right: 10px; font-weight: 700; }
        #messageInput { flex-grow: 1; background: transparent; border: none; outline: none; font-size: 18px; font-family: 'Nanum Gothic Coding', monospace; font-weight: 700; color: #FFFFF0; padding: 0; margin: 0; }
        #messageInput::placeholder { color: rgba(255, 255, 240, 0.5); }

        /* =========================================
           PART 2: 추가된 UI (우측 하단 푸터 & 팝업)
           ========================================= */
        
        /* 우측 하단 컨테이너 (z-index 40: 입력창보다 위에, 클릭 가능하게) */
        #footer-ui-container {
            position: fixed;
            bottom: 30px; 
            right: 40px;
            z-index: 40;
            display: flex;
            align-items: flex-end;
            gap: 20px;
        }

        /* 5초 순환 텍스트 */
        #rotating-text-area {
            color: white;
            font-family: 'Nanum Gothic Coding', monospace; /* 기존 폰트 사용 */
            font-size: 18px; /* 기존 텍스트 크기와 유사하게 */
            text-align: left;
            opacity: 0;
            transition: opacity 1s ease-in-out;
            max-width: 600px; /* 너무 길어지면 줄바꿈 */
            margin-bottom: 5px; /* 아이콘과 높이 시각적 정렬 */
        }

        /* 햄버거 아이콘 (짧은 줄 3개) */
        .hamburger-icon {
            width: 30px;
            height: 24px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            cursor: pointer;
        }
        .hamburger-line {
            width: 100%;
            height: 3px;
            background-color: white;
            transition: all 0.3s;
        }
        .hamburger-icon:hover .hamburger-line {
            background-color: #FFFF00; /* 호버 시 노란색 포인트 */
        }

        /* 정보 팝업창 스타일 */
        #info-popup {
            display: none; /* 기본 숨김 */
            position: fixed;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 500px;
            max-width: 90vw;
            background-color: black;
            border: 1px solid white; /* 흰색 테두리 */
            border-radius: 0; /* 곡선 없음 */
            padding: 40px;
            z-index: 1000; /* 최상단 */
            color: white;
            font-family: 'Wanted Sans Variable', 'Wanted Sans', sans-serif; /* Wanted Sans 적용 */
            font-weight: 700;
        }

        /* 팝업 닫기 버튼 (X) */
        #popup-close-btn {
            position: absolute;
            top: 15px;
            right: 20px;
            font-family: 'Wanted Sans Variable', sans-serif;
            font-size: 24px;
            cursor: pointer;
            color: white;
        }
        
        /* 팝업 내용 텍스트 */
        .popup-content {
            font-size: 18px; /* 기존 영문 폰트 크기와 동일하게 */
            line-height: 1.6;
            text-align: left;
        }

    </style>
</head>
<body>

    <svg id="canvas-container" xmlns="http://www.w3.org/2000/svg"></svg>
    <div id="visualizer-layer"><canvas id="oscilloscope"></canvas></div>
    <div id="nasa-image-layer"></div>
    
    <button id="startBtn">Click here to message with an alien!</button>

    <div id="content-layer">
        <div id="messageLog"></div>
        <div id="input-wrapper">
            <span id="blinking-cursor">/</span>
            <input type="text" id="messageInput" placeholder="Type your message and click Enter." autocomplete="off">
        </div>
    </div>

    <div id="footer-ui-container">
        <div id="rotating-text-area"></div>
        <div class="hamburger-icon" id="menuBtn">
            <div class="hamburger-line"></div>
            <div class="hamburger-line"></div>
            <div class="hamburger-line"></div>
        </div>
    </div>

    <div id="info-popup">
        <div id="popup-close-btn">x</div>
        <div class="popup-content">
            <b>Golden Indexed</b><br><br>
            ‘기호를 활용해 외계인과 소통할 수 있을까?’ 인간의 읽기와 쓰기 체계 중 하나인 기호가 과연 상호작용이 가능한지를 실험해보는 도구 형태의 웹사이트이다. <br><br>
            도구적 형태로 간접 소통해봄으로써 어쩌면 외계인과 소통은 불가능할지도 모르는 전제 하에 인간의 상상력의 한계를 넘어 상상해보고, 인간 문명 속 무모한 낭만과 영감의 시너지를 주고자 한다. <br><br>
            제작 김채린 <br>
        </div>
    </div>

    <script>
        document.addEventListener("DOMContentLoaded", () => {
            
            // [초기화] 새로고침 시 모든 기록 삭제
            localStorage.removeItem('binaryLogData_v2');

            const VISUALIZER_SPACING = 350; 
            const HITBOX_RADIUS = 180; 

            /* =========================================
               PART 0: NASA 이미지 시스템 (중복 방지 추가됨)
               ========================================= */
            const imageLayer = document.getElementById('nasa-image-layer');
            const totalImages = 55; 
            const batchSize = 7;    
            const displayDuration = 15000; 
            const gapDuration = 15000;     
            const cycleInterval = displayDuration + gapDuration; 

            function spawnImageBatch() {
                imageLayer.innerHTML = ''; 

                const placedRects = []; 
                const imgWidthVW = 7.5; 
                const vwToPx = window.innerWidth / 100;
                const imgSizePx = imgWidthVW * vwToPx * 1.5; 

                // [수정] 중복 없는 랜덤 숫자 7개 뽑기
                const selectedIndices = new Set();
                while(selectedIndices.size < batchSize) {
                    selectedIndices.add(Math.floor(Math.random() * totalImages) + 1);
                }

                // 뽑힌 7개 이미지 생성
                selectedIndices.forEach(randomIdx => {
                    const img = document.createElement('img');
                    img.src = `nasa${randomIdx}.jpg`;
                    img.classList.add('nasa-popup-img');
                    
                    let randomX, randomY;
                    let overlapping = true;
                    let attempts = 0;

                    while (overlapping && attempts < 50) {
                        randomX = Math.random() * (window.innerWidth - imgSizePx);
                        randomY = Math.random() * (window.innerHeight - imgSizePx);
                        overlapping = false;
                        for (const rect of placedRects) {
                            const dx = randomX - rect.x;
                            const dy = randomY - rect.y;
                            if (Math.sqrt(dx*dx + dy*dy) < imgSizePx) {
                                overlapping = true; break;
                            }
                        }
                        attempts++;
                    }
                    placedRects.push({x: randomX, y: randomY});

                    img.style.left = `${randomX}px`;
                    img.style.top = `${randomY}px`;
                    const randomRotate = (Math.random() - 0.5) * 60;
                    img.style.transform = `rotate(${randomRotate}deg)`;

                    setupDragAndDrop(img);
                    imageLayer.appendChild(img);
                });

                // 15초 후 사라짐
                setTimeout(() => {
                    const activeImages = document.querySelectorAll('.nasa-popup-img');
                    activeImages.forEach(img => {
                        if (!img.classList.contains('sucked-in')) {
                            img.classList.add('fade-out');
                        }
                    });
                    setTimeout(() => { imageLayer.innerHTML = ''; }, 1000);
                }, displayDuration);
            }

            // 드래그 앤 드롭 로직 (기존 동일)
            function setupDragAndDrop(img) {
                let isDragging = false;
                let startX, startY, initialLeft, initialTop;
                const onMouseDown = (e) => {
                    isDragging = true; startX = e.clientX; startY = e.clientY;
                    initialLeft = parseFloat(img.style.left || 0); initialTop = parseFloat(img.style.top || 0);
                    img.style.animation = 'none'; img.style.transition = 'none'; img.style.zIndex = 9999;
                };
                const onMouseMove = (e) => {
                    if (!isDragging) return; e.preventDefault();
                    const dx = e.clientX - startX; const dy = e.clientY - startY;
                    img.style.left = `${initialLeft + dx}px`; img.style.top = `${initialTop + dy}px`;
                };
                const onMouseUp = (e) => {
                    if (!isDragging) return; isDragging = false;
                    const cx = window.innerWidth / 2; const cy = window.innerHeight / 2;
                    const targets = [{ x: cx - VISUALIZER_SPACING, y: cy }, { x: cx, y: cy }, { x: cx + VISUALIZER_SPACING, y: cy }];
                    const imgRect = img.getBoundingClientRect();
                    const imgCenterX = imgRect.left + imgRect.width / 2;
                    const imgCenterY = imgRect.top + imgRect.height / 2;
                    let hitTarget = null;
                    for (const t of targets) {
                        if (Math.sqrt(Math.pow(imgCenterX - t.x, 2) + Math.pow(imgCenterY - t.y, 2)) < HITBOX_RADIUS) {
                            hitTarget = t; break;
                        }
                    }
                    if (hitTarget) {
                        img.style.transition = 'all 0.5s ease-in';
                        img.style.left = `${hitTarget.x - imgRect.width/2}px`; img.style.top = `${hitTarget.y - imgRect.height/2}px`;
                        img.classList.add('sucked-in'); setTimeout(() => { img.remove(); }, 500);
                    } else {
                        img.style.animation = 'floatSpace 6s ease-in-out infinite alternate';
                        img.style.transition = 'opacity 1s ease-in-out'; img.style.zIndex = '';
                    }
                };
                img.addEventListener('mousedown', onMouseDown);
                window.addEventListener('mousemove', onMouseMove);
                window.addEventListener('mouseup', onMouseUp);
            }

            spawnImageBatch();
            setInterval(spawnImageBatch, cycleInterval);


            /* =========================================
               PART 1: 배경 아트워크 & 비주얼라이저 (기존 동일)
               ========================================= */
            const svg = document.getElementById('canvas-container');
            const setCount = 20; const artRadius = 10; const duration = 6000;   
            let artSets = [];
            function easeInOutQuint(x) { return x < 0.5 ? 16 * x * x * x * x * x : 1 - Math.pow(-2 * x + 2, 5) / 2; }
            class ArtSet {
                constructor(svgContainer, width, height) {
                    this.svg = svgContainer; this.width = width; this.height = height; this.ns = "http://www.w3.org/2000/svg";
                    this.group = document.createElementNS(this.ns, "g"); this.group.classList.add("art-shape");
                    this.line = document.createElementNS(this.ns, "line");
                    this.circleTop = document.createElementNS(this.ns, "circle"); this.circleBottom = document.createElementNS(this.ns, "circle");
                    this.circleTop.setAttribute("r", artRadius); this.circleBottom.setAttribute("r", artRadius);
                    this.group.appendChild(this.line); this.group.appendChild(this.circleTop); this.group.appendChild(this.circleBottom);
                    this.svg.appendChild(this.group); this.initPosition();
                }
                initPosition() {
                    this.y1 = artRadius; this.y2 = this.height - artRadius;
                    this.currX1 = Math.random() * (this.width - artRadius * 2) + artRadius;
                    this.currX2 = Math.random() * (this.width - artRadius * 2) + artRadius;
                    this.startX1 = this.currX1; this.startX2 = this.currX2;
                    this.targetX1 = this.getRandomX(); this.targetX2 = this.getRandomX(); this.startTime = null;
                }
                getRandomX() { return Math.random() * (this.width - artRadius * 2) + artRadius; }
                update(timestamp) {
                    if (!this.startTime) this.startTime = timestamp;
                    const elapsed = timestamp - this.startTime;
                    let progress = Math.min(elapsed / duration, 1);
                    const easedProgress = easeInOutQuint(progress);
                    this.currX1 = this.startX1 + (this.targetX1 - this.startX1) * easedProgress;
                    this.currX2 = this.startX2 + (this.targetX2 - this.startX2) * easedProgress;
                    if (progress >= 1) { this.startTime = timestamp; this.startX1 = this.currX1; this.startX2 = this.currX2; this.targetX1 = this.getRandomX(); this.targetX2 = this.getRandomX(); }
                    this.draw();
                }
                draw() {
                    this.circleTop.setAttribute("cx", this.currX1); this.circleTop.setAttribute("cy", this.y1);
                    this.circleBottom.setAttribute("cx", this.currX2); this.circleBottom.setAttribute("cy", this.y2);
                    const angle = Math.atan2(this.y2 - this.y1, this.currX2 - this.currX1);
                    this.line.setAttribute("x1", this.currX1 + artRadius * Math.cos(angle));
                    this.line.setAttribute("y1", this.y1 + artRadius * Math.sin(angle));
                    this.line.setAttribute("x2", this.currX2 - artRadius * Math.cos(angle));
                    this.line.setAttribute("y2", this.y2 - artRadius * Math.sin(angle));
                }
            }
            function initArt() {
                svg.innerHTML = ''; artSets = [];
                const width = window.innerWidth; const height = window.innerHeight;
                for (let i = 0; i < setCount; i++) { const set = new ArtSet(svg, width, height); set.draw(); artSets.push(set); }
                requestAnimationFrame(animateArt);
            }
            function animateArt(timestamp) { artSets.forEach(set => set.update(timestamp)); requestAnimationFrame(animateArt); }
            initArt(); window.addEventListener('resize', initArt);

            // 오디오 비주얼라이저 (기존 동일)
            const canvas = document.getElementById('oscilloscope'); const ctx = canvas.getContext('2d');
            const startBtn = document.getElementById('startBtn'); const resolution = 2;
            function resizeCanvas() { canvas.width = window.innerWidth * resolution; canvas.height = window.innerHeight * resolution; ctx.scale(resolution, resolution); }
            resizeCanvas(); window.addEventListener('resize', resizeCanvas);
            let audioCtx, analyser, dataArray, bufferLength, isAudioRunning = false;

            startBtn.addEventListener('click', async () => {
                startBtn.style.display = 'none'; isAudioRunning = true;
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    const source = audioCtx.createMediaStreamSource(stream);
                    analyser = audioCtx.createAnalyser(); analyser.fftSize = 2048; analyser.smoothingTimeConstant = 0.85;
                    source.connect(analyser); bufferLength = analyser.frequencyBinCount; dataArray = new Uint8Array(bufferLength);
                    drawVisualizer();
                } catch (err) { console.error(err); alert("마이크 권한이 필요합니다."); }
            });

            function getAverageVolume(array) {
                let values = 0; for (let i = 0; i < array.length; i++) values += Math.abs(array[i] - 128);
                return values / array.length;
            }

            function drawUniqueTriangle(centerX, centerY, radius, data, type) {
                const avgVol = getAverageVolume(data);
                let scale = 1.0 + (avgVol / 128) * (type === 1 ? 0.3 : (type === 0 ? 0.1 : 0.05));
                ctx.save(); ctx.translate(centerX, centerY); ctx.scale(scale, scale); ctx.translate(-centerX, -centerY);
                const vertices = [];
                for(let k=0; k<3; k++) {
                    const theta = -Math.PI / 2 + (k * 2 * Math.PI / 3);
                    vertices.push({ x: centerX + radius * Math.cos(theta), y: centerY + radius * Math.sin(theta) });
                }
                ctx.beginPath();
                const step = Math.ceil(bufferLength / 300);
                for (let i = 0; i < bufferLength; i += step) {
                    const t = i / bufferLength; const sideIndex = Math.floor(t * 3) % 3; const nextSideIndex = (sideIndex + 1) % 3; const segmentT = (t * 3) % 1;
                    const p1 = vertices[sideIndex]; const p2 = vertices[nextSideIndex];
                    const baseX = p1.x + (p2.x - p1.x) * segmentT; const baseY = p1.y + (p2.y - p1.y) * segmentT;
                    let audioValue = 0;
                    if (type === 0) audioValue = (data[i] / 128.0) - 1.0;
                    else if (type === 1) audioValue = -((data[bufferLength - 1 - i] / 128.0) - 1.0) * 1.2;
                    else audioValue = (data[(i * 2) % bufferLength] / 128.0) - 1.0;
                    const displacement = audioValue * 60;
                    const angle = Math.atan2(baseY - centerY, baseX - centerX);
                    const fx = baseX + Math.cos(angle) * displacement; const fy = baseY + Math.sin(angle) * displacement;
                    if (i === 0) ctx.moveTo(fx, fy); else ctx.lineTo(fx, fy);
                }
                ctx.closePath(); ctx.fillStyle = '#000000'; ctx.fill();
                ctx.lineWidth = 20; ctx.strokeStyle = '#FFFF00'; ctx.lineJoin = 'round'; ctx.lineCap = 'round'; ctx.stroke();
                ctx.restore();
            }

            function drawVisualizer() {
                if (!isAudioRunning) return;
                requestAnimationFrame(drawVisualizer);
                analyser.getByteTimeDomainData(dataArray);
                ctx.clearRect(0, 0, canvas.width / resolution, canvas.height / resolution);
                const cx = window.innerWidth / 2; const cy = window.innerHeight / 2;
                const r = 150; const s = VISUALIZER_SPACING; 
                drawUniqueTriangle(cx - s, cy, r, dataArray, 0); drawUniqueTriangle(cx, cy, r, dataArray, 1); drawUniqueTriangle(cx + s, cy, r, dataArray, 2);
            }

            // 메시지 로그 (기존 동일)
            const messageInput = document.getElementById('messageInput'); const messageLog = document.getElementById('messageLog'); const cursor = document.getElementById('blinking-cursor');
            setInterval(() => { cursor.style.opacity = cursor.style.opacity === '0' ? '1' : '0'; }, 500);
            function toBin(n) { return n.toString(2); }
            function getBinaryDateTime() { const n = new Date(); return `${toBin(n.getFullYear())} ${toBin(n.getMonth()+1)} ${toBin(n.getDate())} ${toBin(n.getHours())} ${toBin(n.getMinutes())} ${toBin(n.getSeconds())}`; }
            function renderMessage(t, txt) {
                const d = document.createElement('div'); d.className = 'message-entry';
                d.innerHTML = `<span class="binary-date">${t}</span><span class="message-text">${txt}</span>`;
                messageLog.appendChild(d); window.scrollTo(0, document.body.scrollHeight);
            }
            const saved = localStorage.getItem('binaryLogData_v2');
            if(saved) JSON.parse(saved).forEach(m => renderMessage(m.time, m.text));
            messageInput.addEventListener('keydown', (e) => {
                if(e.key === 'Enter' && messageInput.value.trim()) {
                    const t = getBinaryDateTime(); const txt = messageInput.value.trim();
                    renderMessage(t, txt);
                    const msgs = saved ? JSON.parse(saved) : []; msgs.push({time:t, text:txt});
                    localStorage.setItem('binaryLogData_v2', JSON.stringify(msgs));
                    messageInput.value = '';
                }
            });
            messageInput.focus();


            /* =========================================
               PART 3: 새로 추가된 기능 (팝업 & 순환 텍스트)
               ========================================= */

            // 1. 팝업창 제어
            const menuBtn = document.getElementById('menuBtn');
            const infoPopup = document.getElementById('info-popup');
            const popupCloseBtn = document.getElementById('popup-close-btn');

            menuBtn.addEventListener('click', () => {
                infoPopup.style.display = 'block';
            });
            popupCloseBtn.addEventListener('click', () => {
                infoPopup.style.display = 'none';
            });

            // 2. 텍스트 순환 로직 (5초 간격)
            const rotatingTexts = [
                "Whatever happens in space, whatever the unknown fate,",
                "Human believe this represents the culmination of our civilization's wildest dreams.",
                "This might be inherently impossible for messaging an alien.",
                "But we still need to think radically outside the box and imagine beyond the limits of our imagination.",
                "This would be a bold challenge and a beginning.",
                "And this would be new example and inspiration to others throughout time and across all eras, encouraging them to continue to dream."
            ];

            const textArea = document.getElementById('rotating-text-area');
            let textIndex = 0;

            function updateRotatingText() {
                // 페이드 아웃
                textArea.style.opacity = '0';
                
                setTimeout(() => {
                    // 텍스트 변경
                    textArea.innerText = rotatingTexts[textIndex];
                    textIndex = (textIndex + 1) % rotatingTexts.length;
                    
                    // 페이드 인
                    textArea.style.opacity = '1';
                }, 1000); // 1초 동안 사라짐 -> 텍스트 교체 -> 다시 나타남
            }

            // 초기 실행
            updateRotatingText();
            // 5초마다 반복 (텍스트 교체 주기)
            setInterval(updateRotatingText, 5000);

        });
    </script>
</body>
</html>