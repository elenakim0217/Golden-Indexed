<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Golden Indexed 2.0 - Final Interaction</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Nanum+Gothic+Coding:wght@700&family=Noto+Sans+KR:wght@700&display=swap" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/gh/wanteddev/wanted-sans@v1.0.1/packages/wanted-sans/fonts/webfonts/variable/split/WantedSansVariable.min.css" rel="stylesheet">

    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>

    <style>
        :root {
            --main-yellow: #FBCD0D; 
            --base-font-size: 16px; 
        }

        body {
            margin: 0; padding: 0; background-color: black;
            min-height: 100vh; width: 100vw;
            font-family: 'Nanum Gothic Coding', 'Noto Sans KR', monospace;
            font-weight: 700; overflow: hidden; user-select: none; 
            font-size: var(--base-font-size);
        }

        /* [배경 아트워크] */
        #canvas-container {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 0; pointer-events: none;
        }
        .art-shape { stroke: rgba(255, 255, 255, 0.5); stroke-width: 1px; fill: none; will-change: transform; }

        /* NASA 이미지 레이어 */
        #nasa-image-layer {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 20; pointer-events: none;
        }
        .nasa-popup-img {
            position: absolute; width: 7.5vw; max-height: 15vh;
            object-fit: contain; opacity: 0;
            pointer-events: auto; cursor: grab;
            filter: grayscale(40%) contrast(1.2) brightness(0.8);
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.3); 
            -webkit-user-drag: none; 
            animation: scanEffect 1.5s cubic-bezier(0.1, 0.9, 0.2, 1) forwards, floatSpace 6s ease-in-out infinite alternate;
            transition: opacity 1s ease-in-out;
            will-change: transform, left, top;
        }
        .nasa-popup-img.dragging {
            cursor: grabbing; 
            filter: brightness(1.3) contrast(1.3) drop-shadow(0 0 20px #FBCD0D);
            animation: none !important; opacity: 1 !important; 
            z-index: 99999 !important; transition: none !important; 
        }

        /* 꼴라쥬 레이어 (클릭 통과) */
        #collage-layer {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; 
            display: none; 
            pointer-events: none !important; 
            background-color: transparent; 
        }
        #collage-canvas {
            width: 100%; height: 100%; display: block;
            pointer-events: none !important; 
        }

        @keyframes scanEffect {
            0% { opacity: 0; clip-path: inset(100% 0 0 0); transform: translateY(30px) scale(0.9); filter: brightness(2) contrast(2) hue-rotate(90deg); }
            100% { opacity: 0.8; clip-path: inset(0 0 0 0); transform: translateY(0) scale(1); filter: grayscale(20%) contrast(1.1); }
        }
        @keyframes floatSpace {
            0% { margin-top: 0px; margin-left: 0px; }
            100% { margin-top: -20px; margin-left: 10px; }
        }
        .pop-vanish {
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275) !important; 
            opacity: 0 !important; transform: scale(0.1) rotate(180deg) !important; 
            filter: brightness(10) blur(2px) !important; pointer-events: none; 
        }

        /* 오디오 비주얼라이저 */
        #visualizer-layer {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 5; pointer-events: none; 
            display: flex; align-items: center; justify-content: center;
        }
        canvas#oscilloscope { width: 100%; height: 100%; }

        /* [수정] UI 요소들 - 시작 버튼 배경 추가 */
        #startBtn {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            z-index: 30; padding: 15px 30px;
            font-family: 'Nanum Gothic Coding', monospace; font-size: 16px; font-weight: bold;
            color: var(--main-yellow); 
            
            /* 가독성을 위한 반투명 검정 배경 */
            background-color: rgba(0, 0, 0, 0.7); 
            border: none; 
            border-radius: 0;
            backdrop-filter: blur(2px); /* 배경 흐림 효과 (선택사항) */
            
            cursor: pointer; transition: all 0.3s;
        }
        #startBtn:hover { 
            color: white; 
            background-color: rgba(0, 0, 0, 0.9); /* 호버 시 조금 더 진하게 */
        }

        #content-layer {
            position: relative; z-index: 15; width: 100%; height: 100vh; 
            box-sizing: border-box; padding: 40px;
            display: flex; flex-direction: column; justify-content: space-between;
            pointer-events: none; 
        }
        #messageLog, #footer-bar { pointer-events: auto; }
        #messageLog { width: 100%; flex-grow: 1; display: flex; flex-direction: column; justify-content: flex-end; margin-bottom: 20px; overflow: hidden; }
        .message-entry { display: flex; flex-direction: row; margin-bottom: 10px; line-height: 1.6; color: #FFFFF0; font-size: var(--base-font-size); }
        .binary-date { font-family: 'Nanum Gothic Coding', monospace; white-space: nowrap; margin-right: 25px; color: #FFFFF0; opacity: 0.9; font-size: 12px; line-height: 1.8; }
        .message-text { font-family: 'Nanum Gothic Coding', monospace; word-break: break-all; color: #FFFFF0; font-size: var(--base-font-size); }

        #footer-bar {
            width: 100%; display: flex; flex-direction: row; align-items: center; justify-content: space-between;
            border-top: none; 
            padding-top: 15px; gap: 20px;
        }
        #input-area-left { display: flex; align-items: center; flex-grow: 1; min-width: 200px; margin-right: 20px; }
        #blinking-cursor { font-family: 'Nanum Gothic Coding', monospace; font-size: var(--base-font-size); color: #FFFFF0; margin-right: 10px; font-weight: 800; }
        #messageInput { width: 100%; background: transparent; border: none; outline: none; font-size: var(--base-font-size); font-family: 'Nanum Gothic Coding', monospace; font-weight: 700; color: #FFFFF0; padding: 0; margin: 0; }
        #messageInput::placeholder { color: rgba(255, 255, 240, 0.5); }
        
        #ui-area-right { display: flex; align-items: center; gap: 25px; flex-shrink: 0; }
        
        #rotating-text-area { 
            color: white; font-family: 'Nanum Gothic Coding', monospace; font-size: var(--base-font-size); 
            text-align: right; opacity: 0; transition: opacity 0.5s ease-in-out; white-space: nowrap; 
        }

        #help-msg-area {
            display: none; color: var(--main-yellow); 
            font-family: 'Nanum Gothic Coding', monospace; font-size: var(--base-font-size);
            text-align: right; white-space: nowrap;
        }

        #final-msg-area {
            display: none; color: var(--main-yellow); 
            font-family: 'Nanum Gothic Coding', monospace; font-size: var(--base-font-size);
            text-align: right; white-space: nowrap; cursor: pointer; text-decoration: none;
        }

        #save-icon-btn {
            display: none; width: 24px; height: 24px; cursor: pointer;
            fill: white; transition: fill 0.3s;
            pointer-events: auto; 
        }
        #save-icon-btn:hover { fill: var(--main-yellow); }

        .hamburger-icon { 
            width: 30px; height: auto; display: flex; flex-direction: column; justify-content: center; 
            cursor: pointer; z-index: 2000; pointer-events: auto;
        }
        .hamburger-icon img { width: 100%; height: auto; display: block; transition: all 0.3s; }

        /* 정보 팝업창 */
        #info-popup {
            display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 40vw; min-width: 400px; max-width: 800px; height: auto; max-height: 80vh;
            background-color: black; border: 1px solid white; padding: 40px; 
            z-index: 2100; color: white; 
            font-family: 'Wanted Sans Variable', 'Wanted Sans', sans-serif; font-weight: 700;
            box-sizing: border-box; overflow-y: auto;
        }

        #popup-close-btn { position: absolute; top: 20px; right: 25px; font-family: sans-serif; font-size: 24px; cursor: pointer; color: white; }
        .popup-content { font-size: var(--base-font-size); line-height: 1.8; text-align: left; margin-top: 10px; }
        
        .popup-header-container { display: block; margin-bottom: 20px; min-height: 30px; }
        .popup-title-text { font-family: 'Nanum Gothic Coding', monospace; font-size: 20px; color: var(--main-yellow); display: block; }
        .popup-title-img { max-height: 24px; width: auto; display: none; }

    </style>
</head>
<body>

    <svg id="canvas-container" xmlns="http://www.w3.org/2000/svg"></svg>
    
    <div id="visualizer-layer"><canvas id="oscilloscope"></canvas></div>
    <div id="collage-layer"><canvas id="collage-canvas"></canvas></div>
    <div id="nasa-image-layer"></div>
    
    <button id="startBtn">Click here to message with an alien!</button>

    <div id="content-layer">
        <div id="messageLog"></div>
        <div id="footer-bar">
            <div id="input-area-left">
                <span id="blinking-cursor">/</span>
                <input type="text" id="messageInput" placeholder="Type your message and click Enter." autocomplete="off">
            </div>
            <div id="ui-area-right">
                <div id="rotating-text-area"></div>
                <div id="help-msg-area">Randomly insert the images into 3 kinds of triangles for message input.</div>
                
                <div id="final-msg-area" onclick="location.reload()">Click here to remessage with aliens forever.</div>
                <svg id="save-icon-btn" viewBox="0 0 24 24">
                    <path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/>
                </svg>
                
                <div class="hamburger-icon" id="menuBtn">
                    <img src="icon2.png" alt="Menu" id="menu-icon-img">
                </div>
            </div>
        </div>
    </div>

    <div id="info-popup">
        <div id="popup-close-btn">✕</div>
        <div class="popup-content">
            <div class="popup-header-container">
                <span id="popup-text-title" class="popup-title-text">Golden Indexed</span>
                <img src="title.png" id="popup-img-title" class="popup-title-img" alt="Golden Indexed Title">
            </div>
            
            ‘기호를 활용해 외계인과 소통할 수 있을까?’<br>
            인간의 읽기와 쓰기 체계 중 하나인 기호가 과연 상호작용이 가능한지를 실험해보는 도구 형태의 웹사이트이다. <br><br>
            도구적 형태로 간접 소통해봄으로써 어쩌면 외계인과 소통은 불가능할지도 모르는 전제 하에 인간의 상상력의 한계를 넘어 상상해보고, 인간 문명 속 무모한 낭만과 영감의 시너지를 주고자 한다. <br><br>
            제작 김채린 <br>
        </div>
    </div>

    <script>
        document.addEventListener("DOMContentLoaded", () => {
            
            localStorage.removeItem('binaryLogData_v2');

            // [설정] 
            const INITIAL_SPACING = 350; 
            const HITBOX_RADIUS = 160; 
            const MERGE_DURATION = 3200; 
            const IDLE_LIMIT = 15000; 

            // [상태 변수]
            let currentSpacing = INITIAL_SPACING; 
            let droppedImageCount = 0; 
            let isMerging = false; 
            let mergeStartTime = null; 
            let flowOffset = 0; 
            const droppedImages = { 0: [], 1: [], 2: [] };

            let idleTimeout;
            let isHelpMode = false;
            let helpInterval;
            let hasInteracted = false; 

            const txtArea = document.getElementById('rotating-text-area');
            const helpArea = document.getElementById('help-msg-area');

            /* 1. 배경 아트워크 애니메이션 */
            const svgContainer = document.getElementById('canvas-container');
            const setArtCount = 20; const artRadius = 10; 

            function easeInOutQuintArt(x) { return x < 0.5 ? 16 * x * x * x * x * x : 1 - Math.pow(-2 * x + 2, 5) / 2; }
            
            class ArtSet {
                constructor(svg, w, h) {
                    this.svg = svg; this.w = w; this.h = h; this.ns = "http://www.w3.org/2000/svg";
                    this.g = document.createElementNS(this.ns, "g"); this.g.classList.add("art-shape");
                    this.line = document.createElementNS(this.ns, "line");
                    this.c1 = document.createElementNS(this.ns, "circle"); this.c2 = document.createElementNS(this.ns, "circle");
                    this.c1.setAttribute("r", artRadius); this.c2.setAttribute("r", artRadius);
                    this.g.appendChild(this.line); this.g.appendChild(this.c1); this.g.appendChild(this.c2);
                    this.svg.appendChild(this.g); this.init();
                }
                init() {
                    this.y1 = artRadius; this.y2 = this.h - artRadius;
                    this.currX1 = Math.random() * (this.w - 20) + 10; this.currX2 = Math.random() * (this.w - 20) + 10;
                    this.startX1 = this.currX1; this.startX2 = this.currX2;
                    this.targetX1 = Math.random() * (this.w - 20) + 10; this.targetX2 = Math.random() * (this.w - 20) + 10;
                    this.startTime = null;
                }
                update(t) {
                    if (!this.startTime) this.startTime = t;
                    const p = Math.min((t - this.startTime) / 6000, 1);
                    const ep = easeInOutQuintArt(p);
                    this.currX1 = this.startX1 + (this.targetX1 - this.startX1) * ep;
                    this.currX2 = this.startX2 + (this.targetX2 - this.startX2) * ep;
                    if (p >= 1) { 
                        this.startTime = t; this.startX1 = this.currX1; this.startX2 = this.currX2; 
                        this.targetX1 = Math.random() * (this.w-20)+10; this.targetX2 = Math.random() * (this.w-20)+10; 
                    }
                    this.draw();
                }
                draw() {
                    this.c1.setAttribute("cx", this.currX1); this.c1.setAttribute("cy", this.y1);
                    this.c2.setAttribute("cx", this.currX2); this.c2.setAttribute("cy", this.y2);
                    const a = Math.atan2(this.y2 - this.y1, this.currX2 - this.currX1);
                    this.line.setAttribute("x1", this.currX1 + 10 * Math.cos(a)); this.line.setAttribute("y1", this.y1 + 10 * Math.sin(a));
                    this.line.setAttribute("x2", this.currX2 - 10 * Math.cos(a)); this.line.setAttribute("y2", this.y2 - 10 * Math.sin(a));
                }
            }
            
            let artSets = [];
            function initArt() { 
                svgContainer.innerHTML = ''; artSets = []; 
                for(let i=0; i<setArtCount; i++) artSets.push(new ArtSet(svgContainer, window.innerWidth, window.innerHeight)); 
                requestAnimationFrame(animateArt); 
            }
            function animateArt(t) { artSets.forEach(s => s.update(t)); requestAnimationFrame(animateArt); }
            initArt(); window.addEventListener('resize', initArt);


            /* [유휴 감지] */
            function resetIdleTimer() {
                if (hasInteracted || isMerging) return;
                clearTimeout(idleTimeout);
                if (!isHelpMode) {
                    idleTimeout = setTimeout(showHelpMode, IDLE_LIMIT);
                }
            }

            function showHelpMode() {
                if (hasInteracted || isMerging) return;
                isHelpMode = true;
                clearInterval(textInterval);
                txtArea.style.display = 'none';
                helpArea.style.display = 'block';
                let visible = true;
                helpArea.style.opacity = '1';
                helpInterval = setInterval(() => {
                    visible = !visible;
                    helpArea.style.opacity = visible ? '1' : '0';
                }, 500);
            }

            function endHelpMode() {
                if (!isHelpMode) return; 
                isHelpMode = false;
                hasInteracted = true; 
                clearInterval(helpInterval);
                helpArea.style.display = 'none';
                txtArea.style.display = 'block';
                txtArea.style.opacity = '1'; 
                rotateText();
                textInterval = setInterval(rotateText, 5000);
            }

            window.addEventListener('mousemove', resetIdleTimer);
            window.addEventListener('mousedown', resetIdleTimer);
            resetIdleTimer();


            /* NASA 이미지 시스템 */
            const imageLayer = document.getElementById('nasa-image-layer');
            const totalImages = 55; 
            const batchSize = 7;    

            function spawnImageBatch() {
                imageLayer.innerHTML = ''; 
                const placedRects = []; 
                const imgWidthVW = 7.5; 
                const vwToPx = window.innerWidth / 100;
                const imgSizePx = imgWidthVW * vwToPx * 1.5; 

                const selectedIndices = new Set();
                while(selectedIndices.size < batchSize) {
                    selectedIndices.add(Math.floor(Math.random() * totalImages) + 1);
                }

                selectedIndices.forEach(randomIdx => {
                    const img = document.createElement('img');
                    img.src = `nasa${randomIdx}.jpg`;
                    img.classList.add('nasa-popup-img');
                    
                    let randomX, randomY;
                    let overlapping = true;
                    let attempts = 0;

                    while (overlapping && attempts < 100) {
                        overlapping = false;
                        randomX = Math.random() * (window.innerWidth - imgSizePx);
                        randomY = Math.random() * (window.innerHeight - imgSizePx);

                        for (const rect of placedRects) {
                            const dx = randomX - rect.x;
                            const dy = randomY - rect.y;
                            if (Math.sqrt(dx*dx + dy*dy) < imgSizePx) {
                                overlapping = true; break;
                            }
                        }
                        attempts++;
                    }

                    placedRects.push({x: randomX, y: randomY});
                    img.style.left = `${randomX}px`; img.style.top = `${randomY}px`;
                    img.style.transform = `rotate(${(Math.random() - 0.5) * 60}deg)`;

                    setupDragAndDrop(img);
                    imageLayer.appendChild(img);
                });
            }

            // [드래그 앤 드롭 로직]
            function setupDragAndDrop(img) {
                let isDragging = false;
                let dragOffsetX = 0;
                let dragOffsetY = 0;
                
                const onMouseDown = (e) => {
                    if (e.button !== 0) return; 
                    e.preventDefault(); 
                    isDragging = true;
                    img.classList.add('dragging');
                    const rect = img.getBoundingClientRect();
                    dragOffsetX = e.clientX - rect.left;
                    dragOffsetY = e.clientY - rect.top;
                };

                const onMouseMove = (e) => {
                    if (!isDragging) return;
                    e.preventDefault();
                    img.style.left = `${e.clientX - dragOffsetX}px`;
                    img.style.top = `${e.clientY - dragOffsetY}px`;
                };

                const onMouseUp = (e) => {
                    if (!isDragging) return;
                    isDragging = false;
                    img.classList.remove('dragging');

                    if (!audioOn) {
                        img.style.transition = 'opacity 1s ease-in-out'; 
                        return;
                    }

                    const cx = window.innerWidth / 2; 
                    const cy = window.innerHeight / 2;
                    const targets = [
                        { x: cx - currentSpacing, y: cy, id: 0 }, 
                        { x: cx, y: cy, id: 1 },                  
                        { x: cx + currentSpacing, y: cy, id: 2 }  
                    ];
                    
                    let hitTarget = null;
                    for (const t of targets) {
                        const dist = Math.sqrt(Math.pow(e.clientX - t.x, 2) + Math.pow(e.clientY - t.y, 2));
                        if (dist < HITBOX_RADIUS) { 
                            hitTarget = t; break; 
                        }
                    }

                    if (hitTarget) {
                        if (isHelpMode) endHelpMode();
                        hasInteracted = true; 
                        clearTimeout(idleTimeout);

                        droppedImages[hitTarget.id].push(img.src);
                        img.style.transition = 'all 0.3s ease-out';
                        img.style.left = `${hitTarget.x - img.offsetWidth/2}px`;
                        img.style.top = `${hitTarget.y - img.offsetHeight/2}px`;
                        requestAnimationFrame(() => { img.classList.add('pop-vanish'); });
                        setTimeout(() => { img.remove(); }, 300);

                        droppedImageCount++;
                        if (droppedImageCount >= batchSize) {
                            startMergingSequence();
                        }
                    } else {
                        img.style.transition = 'opacity 1s ease-in-out'; 
                    }
                };

                img.addEventListener('mousedown', onMouseDown);
                window.addEventListener('mousemove', onMouseMove);
                window.addEventListener('mouseup', onMouseUp);
            }
            
            function startMergingSequence() {
                isMerging = true;
                mergeStartTime = null; 
                triggerSpecialTextMode();
            }
            
            spawnImageBatch(); 


            /* 비주얼라이저 */
            const canvas = document.getElementById('oscilloscope'); const ctx = canvas.getContext('2d');
            const startBtn = document.getElementById('startBtn'); const res = 2;
            function resizeC() { canvas.width = window.innerWidth * res; canvas.height = window.innerHeight * res; ctx.scale(res, res); }
            resizeC(); window.addEventListener('resize', resizeC);
            let actx, anl, dArray, bufLen, audioOn = false;

            startBtn.addEventListener('click', async () => {
                startBtn.style.display = 'none'; audioOn = true;
                actx = new (window.AudioContext || window.webkitAudioContext)();
                try {
                    const strm = await navigator.mediaDevices.getUserMedia({ audio: true });
                    const src = actx.createMediaStreamSource(strm);
                    anl = actx.createAnalyser(); anl.fftSize = 2048; anl.smoothingTimeConstant = 0.85;
                    src.connect(anl); bufLen = anl.frequencyBinCount; dArray = new Uint8Array(bufLen);
                    drawVis();
                } catch (e) { console.error(e); alert("마이크 권한 필요"); }
            });

            function easeInOutQuint(x) { return x < 0.5 ? 16 * x * x * x * x * x : 1 - Math.pow(-2 * x + 2, 5) / 2; }

            function drawVis() {
                if (!audioOn) return; 
                requestAnimationFrame(drawVis);
                anl.getByteTimeDomainData(dArray);
                ctx.clearRect(0, 0, canvas.width/res, canvas.height/res);
                
                flowOffset -= 0.3; 

                let morphValue = 0; 
                if (isMerging) {
                    if (!mergeStartTime) mergeStartTime = performance.now();
                    const elapsed = performance.now() - mergeStartTime;
                    let progress = Math.min(elapsed / MERGE_DURATION, 1);
                    const easedProgress = easeInOutQuint(progress);
                    currentSpacing = INITIAL_SPACING * (1 - easedProgress); 
                    morphValue = easedProgress; 
                }

                const cx = window.innerWidth/2, cy = window.innerHeight/2;
                drawMorphShape(cx - currentSpacing, cy, 150, 0, morphValue); 
                drawMorphShape(cx, cy, 150, 1, morphValue); 
                drawMorphShape(cx + currentSpacing, cy, 150, 2, morphValue);
            }

            // 기계식 점선 및 틱 그리기 함수
            function drawMorphShape(cx, cy, r, type, morphValue) {
                let vol = 0; for(let i=0; i<dArray.length; i++) vol += Math.abs(dArray[i]-128); vol /= dArray.length;
                let sc = 1 + (vol/128) * (type===1?0.3:(type===0?0.1:0.05));
                
                ctx.save(); ctx.translate(cx, cy); ctx.scale(sc, sc); ctx.translate(-cx, -cy);

                const basePoints = [];
                const points = [];
                
                const triPts = []; 
                for(let k=0; k<3; k++) {
                    triPts.push({ x: cx + r * Math.cos(-Math.PI/2 + k*2*Math.PI/3), y: cy + r * Math.sin(-Math.PI/2 + k*2*Math.PI/3) });
                }
                const step = Math.ceil(bufLen/300);
                for(let i=0; i<bufLen; i+=step) {
                    const t = i/bufLen;
                    const si = Math.floor(t*3)%3; const nsi = (si+1)%3; const st = (t*3)%1;
                    
                    const triX = triPts[si].x + (triPts[nsi].x - triPts[si].x)*st;
                    const triY = triPts[si].y + (triPts[nsi].y - triPts[si].y)*st;
                    
                    const circleAngle = -Math.PI/2 + (t * 2 * Math.PI);
                    const circleX = cx + r * Math.cos(circleAngle);
                    const circleY = cy + r * Math.sin(circleAngle);
                    
                    const basePathX = triX * (1 - morphValue) + circleX * morphValue;
                    const basePathY = triY * (1 - morphValue) + circleY * morphValue;
                    
                    basePoints.push({x: basePathX, y: basePathY});

                    let rawVal = 0;
                    if (type === 0) rawVal = (dArray[i] / 128.0) - 1.0;
                    else if (type === 1) rawVal = -((dArray[bufLen - 1 - i] / 128.0) - 1.0) * 1.2;
                    else rawVal = (dArray[(i * 2) % bufLen] / 128.0) - 1.0;
                    
                    const angleFromCenter = Math.atan2(basePathY - cy, basePathX - cx);
                    const displacement = rawVal * 60; 
                    const fx = basePathX + Math.cos(angleFromCenter) * displacement;
                    const fy = basePathY + Math.sin(angleFromCenter) * displacement;
                    
                    points.push({x: fx, y: fy});
                }

                // 배경 점선
                ctx.beginPath();
                ctx.lineWidth = 20; // 두께
                ctx.setLineDash([25, 35]); 
                ctx.strokeStyle = '#FBCD0D'; 
                ctx.lineJoin = 'round'; ctx.lineCap = 'round'; 
                
                if(points.length > 0) {
                    ctx.moveTo(points[0].x, points[0].y);
                    for(let i=1; i<points.length; i++) ctx.lineTo(points[i].x, points[i].y);
                    ctx.lineTo(points[0].x, points[0].y);
                }
                ctx.stroke();

                // 틱 그리기
                ctx.setLineDash([]); 
                ctx.lineWidth = 20; 
                ctx.beginPath();

                const totalPts = basePoints.length;
                const tickSpacing = 50; 
                
                const phaseShift = Math.floor(totalPts * 0.17); 

                for(let i=0; i<totalPts; i++) {
                    const movingIndex = Math.floor(i - flowOffset - phaseShift);
                    const patternPos = ((movingIndex % tickSpacing) + tickSpacing) % tickSpacing;
                    const groupIndex = Math.floor(movingIndex / tickSpacing);

                    let shouldDraw = false;
                    if (patternPos === 0) shouldDraw = true;
                    if (groupIndex % 2 === 0 && patternPos === 20) shouldDraw = true;

                    if (shouldDraw) {
                        const p1 = basePoints[i];
                        const p2 = basePoints[(i+1) % totalPts];

                        const dx = p2.x - p1.x; const dy = p2.y - p1.y;
                        const angle = Math.atan2(dy, dx);
                        const perpAngle = angle - Math.PI / 2; 

                        const tickLen = 18; 
                        const tx = p1.x + Math.cos(perpAngle) * tickLen;
                        const ty = p1.y + Math.sin(perpAngle) * tickLen;

                        ctx.moveTo(p1.x, p1.y);
                        ctx.lineTo(tx, ty);
                    }
                }
                ctx.stroke();
                ctx.restore();
            }


            /* UI 및 텍스트 로직 */
            const msgIn = document.getElementById('messageInput'); const msgLog = document.getElementById('messageLog'); const cursor = document.getElementById('blinking-cursor');
            setInterval(() => { cursor.style.opacity = cursor.style.opacity === '0' ? '1' : '0'; }, 500);
            function toBin(n) { return n.toString(2); }
            function getBinTime() { const n = new Date(); return `${toBin(n.getFullYear())} ${toBin(n.getMonth()+1)} ${toBin(n.getDate())} ${toBin(n.getHours())} ${toBin(n.getMinutes())} ${toBin(n.getSeconds())}`; }
            function addMsg(t, txt) {
                const d = document.createElement('div'); d.className = 'message-entry';
                d.innerHTML = `<span class="binary-date">${t}</span><span class="message-text">${txt}</span>`;
                msgLog.appendChild(d); msgLog.scrollTop = msgLog.scrollHeight;
            }
            msgIn.addEventListener('keydown', (e) => {
                if(e.key === 'Enter' && msgIn.value.trim()) {
                    addMsg(getBinTime(), msgIn.value.trim()); msgIn.value = '';
                }
            });

            /* 팝업 토글 로직 & 메뉴 아이콘 호버 효과 */
            const menuBtn = document.getElementById('menuBtn');
            const menuIconImg = document.getElementById('menu-icon-img'); // 아이콘 이미지 ID
            const infoPopup = document.getElementById('info-popup');
            const closeBtn = document.getElementById('popup-close-btn');
            
            // 호버 시 노란색(icon1), 뗄 때 흰색(icon2)
            menuBtn.addEventListener('mouseenter', () => {
                menuIconImg.src = 'icon1.png';
            });
            menuBtn.addEventListener('mouseleave', () => {
                menuIconImg.src = 'icon2.png';
            });

            // 클릭 시 팝업 토글 및 아이콘 상태 유지
            menuBtn.addEventListener('click', (e) => {
                e.stopPropagation(); 
                if (infoPopup.style.display === 'block') {
                    infoPopup.style.display = 'none';
                } else {
                    infoPopup.style.display = 'block';
                    menuIconImg.src = 'icon1.png';
                }
            });

            closeBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                infoPopup.style.display = 'none';
            });

            /* 팝업 타이틀 애니메이션 (5초 간격) */
            const titleText = document.getElementById('popup-text-title');
            const titleImg = document.getElementById('popup-img-title');
            let showTitleImg = false; 

            setInterval(() => {
                showTitleImg = !showTitleImg; 
                if (showTitleImg) {
                    titleText.style.display = 'none';
                    titleImg.style.display = 'block';
                } else {
                    titleText.style.display = 'block';
                    titleImg.style.display = 'none';
                }
            }, 5000);


            const texts = [
                "Whatever happens in space, whatever the unknown fate,",
                "Human believe this represents the culmination of our civilization's wildest dreams.",
                "This might be inherently impossible for messaging an alien.",
                "But we still need to think radically outside the box and imagine",
                "beyond the limits of our imagination.",
                "This would be a bold challenge and a beginning.",
                "And this would be new example and inspiration to others throughout",
                "time and across all eras, encouraging them to continue to dream."
            ];
            let txtIdx = 0;
            let textInterval = null; 

            function rotateText() {
                txtArea.style.opacity = '0';
                setTimeout(() => {
                    txtArea.innerText = texts[txtIdx];
                    txtIdx = (txtIdx + 1) % texts.length;
                    txtArea.style.opacity = '1';
                }, 1000); 
            }
            rotateText();
            textInterval = setInterval(rotateText, 5000);

            function triggerSpecialTextMode() {
                clearInterval(textInterval);
                txtArea.style.opacity = '0';

                if(isHelpMode) endHelpMode(); 
                clearInterval(textInterval); 
                helpArea.style.display = 'none';

                setTimeout(() => {
                    const specialMsg = "Ready to communicate with aliens. Typing a message...";
                    txtArea.innerText = specialMsg;
                    txtArea.style.color = "var(--main-yellow)"; 
                    txtArea.style.textDecoration = "none";

                    let blinkState = true;
                    txtArea.style.opacity = '1';

                    const blinkInterval = setInterval(() => {
                        blinkState = !blinkState;
                        txtArea.style.opacity = blinkState ? '1' : '0';
                    }, 500);

                    setTimeout(() => {
                        clearInterval(blinkInterval);
                        txtArea.style.opacity = '0'; 
                        setTimeout(() => {
                            initCollageParticles(); 
                        }, 500);
                    }, 10000);

                }, 1000);
            }


            /* 파티클 꼴라쥬 시스템 */
            let pCanvas, pCtx;
            let particles = [];
            const GAP = 4; 
            let pTime = 0;
            let collageAnimationId;

            class Particle {
                constructor(x, y, color, mode) {
                    this.ox = x; this.oy = y;
                    this.x = x + (Math.random() - 0.5) * 500; 
                    this.y = y + (Math.random() - 0.5) * 500;
                    this.color = color;
                    this.mode = mode; 
                    this.ease = 0.08;
                }
                
                update(width, height) {
                    let tx = this.ox, ty = this.oy;
                    const cx = this.ox; const cy = this.oy;
                    const screenCx = width / 2; const screenCy = height / 2;

                    // Modes 1~10 Implementation
                    if (this.mode === 1) { 
                        tx = cx + Math.sin(cy * 0.01 + pTime) * 20; ty = cy + Math.cos(cx * 0.01 + pTime) * 20;
                    } else if (this.mode === 2) { 
                        const dx = cx - screenCx; const dy = cy - screenCy;
                        const angle = Math.atan2(dy, dx); const r = Math.sqrt(dx*dx + dy*dy);
                        const twist = r * 0.005 - pTime * 2;
                        tx = screenCx + Math.cos(angle + twist) * r; ty = screenCy + Math.sin(angle + twist) * r;
                    } else if (this.mode === 3) { 
                        tx = cx + Math.sin(cy * 0.05 + pTime * 3) * 50;
                    } else if (this.mode === 4) { 
                        const pulse = Math.sin(pTime * 2) * 50;
                        const dx = cx - screenCx; const dy = cy - screenCy;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if(dist < 200 + pulse) { tx += (Math.random()-0.5) * 50; ty += (Math.random()-0.5) * 50; }
                    } else if (this.mode === 5) { 
                        const flow = (pTime * 50) % (height + 100);
                        const noise = Math.sin(cx * 0.05) * 10;
                        if (cy + flow + noise > height) ty = (cy + flow + noise) - height; else ty = cy + flow + noise; 
                    } else if (this.mode === 6) { 
                        if(Math.random() > 0.98) tx = cx + (Math.random()-0.5) * 100;
                    } else if (this.mode === 7) { 
                        const i = (this.ox * 0.01 + this.oy * 0.01);
                        const r = 20 + (pTime * 10 % 100);
                        tx = cx + Math.cos(i + pTime) * r; ty = cy + Math.sin(i + pTime) * r;
                    } else if (this.mode === 8) { 
                        ty = cy + Math.sin(cx * 0.05 + pTime * 3) * 30;
                    } else if (this.mode === 9) { 
                        tx = cx + Math.sin(pTime * 5 + this.oy) * 10; ty = cy + Math.cos(pTime * 5 + this.ox) * 10;
                    } else if (this.mode === 10) { 
                        tx = cx + (Math.random()-0.5) * 20; ty = cy + (Math.random()-0.5) * 20;
                    }

                    this.x += (tx - this.x) * this.ease;
                    this.y += (ty - this.y) * this.ease;
                }

                draw(ctx) {
                    ctx.fillStyle = this.color;
                    ctx.fillRect(this.x, this.y, GAP, GAP);
                }
            }

            function initCollageParticles() {
                document.getElementById('visualizer-layer').style.display = 'none';
                document.getElementById('collage-layer').style.display = 'block';
                
                const rotateArea = document.getElementById('rotating-text-area');
                const finalMsg = document.getElementById('final-msg-area');
                const saveIcon = document.getElementById('save-icon-btn');

                rotateArea.style.display = 'none'; 
                finalMsg.style.display = 'block';
                saveIcon.style.display = 'block';

                let finalBlink = true;
                setInterval(() => {
                    finalBlink = !finalBlink;
                    finalMsg.style.opacity = finalBlink ? '1' : '0';
                }, 500);

                pCanvas = document.getElementById('collage-canvas');
                pCtx = pCanvas.getContext('2d');
                pCanvas.width = window.innerWidth;
                pCanvas.height = window.innerHeight;

                particles = [];
                
                const rowHeights = [window.innerHeight * 0.2, window.innerHeight * 0.5, window.innerHeight * 0.8];
                const imgSize = 200; 
                const promises = [];

                for(let r=0; r<3; r++) { 
                    const imgs = droppedImages[r];
                    // [수정] 랜덤 겹침(Overlap) 위치 계산
                    const startX = (window.innerWidth - (imgs.length * imgSize)) / 2;

                    imgs.forEach((src, idx) => {
                        const p = new Promise((resolve) => {
                            const img = new Image();
                            img.crossOrigin = "Anonymous"; 
                            img.src = src;
                            img.onload = () => {
                                const tmpC = document.createElement('canvas');
                                tmpC.width = imgSize; tmpC.height = imgSize;
                                const tmpCtx = tmpC.getContext('2d');
                                tmpCtx.drawImage(img, 0, 0, imgSize, imgSize);
                                
                                try {
                                    const data = tmpCtx.getImageData(0, 0, imgSize, imgSize).data;
                                    let mode;
                                    if(r === 0) mode = Math.floor(Math.random() * 3) + 1; 
                                    else if(r === 1) mode = Math.floor(Math.random() * 3) + 4; 
                                    else mode = Math.floor(Math.random() * 4) + 7; 

                                    // 랜덤 겹침(Overlap) 위치 계산
                                    let baseDrawX = startX + idx * (imgSize - 20);
                                    let baseDrawY = rowHeights[r] - imgSize/2;

                                    const randomShiftX = (Math.random() - 0.5) * 120; 
                                    const randomShiftY = (Math.random() - 0.5) * 80;

                                    const drawX = baseDrawX + randomShiftX;
                                    const drawY = baseDrawY + randomShiftY;

                                    for(let y=0; y<imgSize; y+=GAP) {
                                        for(let x=0; x<imgSize; x+=GAP) {
                                            const i = (y * imgSize + x) * 4;
                                            const a = data[i+3];
                                            if(a > 50) { 
                                                const color = `rgb(${data[i]},${data[i+1]},${data[i+2]})`;
                                                particles.push(new Particle(drawX + x, drawY + y, color, mode));
                                            }
                                        }
                                    }
                                } catch(e) { console.warn(e); }
                                resolve();
                            };
                            img.onerror = resolve; 
                        });
                        promises.push(p);
                    });
                }

                Promise.all(promises).then(() => { animateCollage(); });

                saveIcon.addEventListener('click', () => {
                    const contentLayer = document.getElementById('content-layer');
                    const startBtn = document.getElementById('startBtn');
                    const infoPopup = document.getElementById('info-popup');

                    contentLayer.style.display = 'none';
                    if(startBtn) startBtn.style.display = 'none';
                    if(infoPopup) infoPopup.style.display = 'none';

                    html2canvas(document.body, {
                        backgroundColor: "black",
                        scale: 2, useCORS: true, allowTaint: true 
                    }).then(canvas => {
                        const link = document.createElement('a');
                        link.download = 'golden_message.jpg';
                        link.href = canvas.toDataURL('image/jpeg');
                        link.click();
                    }).catch(err => { alert("캡쳐 오류 발생"); }).finally(() => { contentLayer.style.display = 'flex'; });
                });
            }

            function animateCollage() {
                pCtx.clearRect(0, 0, pCanvas.width, pCanvas.height);
                pTime += 0.05;
                particles.forEach(p => {
                    p.update(pCanvas.width, pCanvas.height);
                    p.draw(pCtx);
                });
                collageAnimationId = requestAnimationFrame(animateCollage);
            }

        });
    </script>
</body>
</html>