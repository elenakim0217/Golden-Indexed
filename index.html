<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Golden Indexed</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Nanum+Gothic+Coding:wght@700&family=Noto+Sans+KR:wght@700&display=swap" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/gh/wanteddev/wanted-sans@v1.0.1/packages/wanted-sans/fonts/webfonts/variable/split/WantedSansVariable.min.css" rel="stylesheet">

    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>

    <style>
        :root {
            --main-yellow: #FBCD0D; 
            --base-font-size: 16px; 
        }

        body {
            margin: 0; padding: 0; background-color: black;
            min-height: 100vh; width: 100vw;
            font-family: 'Nanum Gothic Coding', 'Noto Sans KR', monospace;
            font-weight: 700; overflow: hidden; user-select: none; 
            font-size: var(--base-font-size);
        }

        #canvas-container {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 0; pointer-events: none;
        }
        .art-shape { stroke: rgba(255, 255, 255, 0.5); stroke-width: 1px; fill: none; will-change: transform; }

        #nasa-image-layer {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 20; pointer-events: none;
        }
        .nasa-popup-img {
            position: absolute; width: 7.5vw; max-height: 15vh;
            object-fit: contain; opacity: 0;
            pointer-events: auto; cursor: grab;
            filter: grayscale(40%) contrast(1.2) brightness(0.8);
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.3); 
            -webkit-user-drag: none; 
            animation: scanEffect 1.5s cubic-bezier(0.1, 0.9, 0.2, 1) forwards, floatSpace 6s ease-in-out infinite alternate;
            transition: opacity 1s ease-in-out;
            will-change: transform, left, top;
        }
        .nasa-popup-img.dragging {
            cursor: grabbing; 
            filter: brightness(1.3) contrast(1.3) drop-shadow(0 0 20px #FBCD0D);
            animation: none !important; opacity: 1 !important; 
            z-index: 99999 !important; transition: none !important; 
        }

        #collage-layer {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; 
            display: none; 
            pointer-events: none !important; 
            background-color: transparent; 
        }
        #collage-canvas {
            width: 100%; height: 100%; display: block;
            pointer-events: none !important; 
        }

        @keyframes scanEffect {
            0% { opacity: 0; clip-path: inset(100% 0 0 0); transform: translateY(30px) scale(0.9); filter: brightness(2) contrast(2) hue-rotate(90deg); }
            100% { opacity: 0.8; clip-path: inset(0 0 0 0); transform: translateY(0) scale(1); filter: grayscale(20%) contrast(1.1); }
        }
        @keyframes floatSpace {
            0% { margin-top: 0px; margin-left: 0px; }
            100% { margin-top: -20px; margin-left: 10px; }
        }
        .pop-vanish {
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275) !important; 
            opacity: 0 !important; transform: scale(0.1) rotate(180deg) !important; 
            filter: brightness(10) blur(2px) !important; pointer-events: none; 
        }

        #visualizer-layer {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 5; pointer-events: none; 
            display: flex; align-items: center; justify-content: center;
        }
        canvas#oscilloscope { width: 100%; height: 100%; }

        #startBtn {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            z-index: 30; padding: 15px 30px;
            font-family: 'Nanum Gothic Coding', monospace; font-size: 16px; font-weight: bold;
            color: var(--main-yellow); 
            background-color: rgba(0, 0, 0, 0.7); 
            border: none; border-radius: 0; backdrop-filter: blur(2px);
            cursor: pointer; transition: all 0.3s;
        }
        #startBtn:hover { color: white; background-color: rgba(0, 0, 0, 0.9); }

        #content-layer {
            position: relative; z-index: 15; width: 100%; height: 100vh; 
            box-sizing: border-box; padding: 40px;
            display: flex; flex-direction: column; justify-content: space-between;
            pointer-events: none; 
        }
        #messageLog, #footer-bar { pointer-events: auto; }
        #messageLog { 
            width: 100%; flex-grow: 1; display: flex; flex-direction: column; 
            margin-bottom: 20px; overflow-y: auto;
            scrollbar-width: none; -ms-overflow-style: none;
        }
        #messageLog::-webkit-scrollbar { display: none; }

        .message-entry { display: flex; flex-direction: row; margin-bottom: 10px; line-height: 1.6; color: #FFFFF0; font-size: var(--base-font-size); flex-shrink: 0; }
        .binary-date { font-family: 'Nanum Gothic Coding', monospace; white-space: nowrap; margin-right: 25px; color: #FFFFF0; opacity: 0.9; font-size: 12px; line-height: 1.8; }
        .message-text { font-family: 'Nanum Gothic Coding', monospace; word-break: break-all; color: #FFFFF0; font-size: var(--base-font-size); }

        #footer-bar {
            width: 100%; display: flex; flex-direction: row; align-items: center; justify-content: space-between;
            border-top: none; padding-top: 15px; gap: 20px; flex-shrink: 0;
        }
        #input-area-left { display: flex; align-items: center; flex-grow: 1; min-width: 200px; margin-right: 20px; }
        #blinking-cursor { font-family: 'Nanum Gothic Coding', monospace; font-size: var(--base-font-size); color: #FFFFF0; margin-right: 10px; font-weight: 800; }
        #messageInput { width: 100%; background: transparent; border: none; outline: none; font-size: var(--base-font-size); font-family: 'Nanum Gothic Coding', monospace; font-weight: 700; color: #FFFFF0; padding: 0; margin: 0; }
        #messageInput::placeholder { color: rgba(255, 255, 240, 0.5); }
        
        #ui-area-right { display: flex; align-items: center; gap: 25px; flex-shrink: 0; }
        
        #rotating-text-area { 
            color: white; font-family: 'Nanum Gothic Coding', monospace; font-size: var(--base-font-size); 
            text-align: right; opacity: 0; transition: opacity 0.5s ease-in-out; white-space: nowrap; 
        }

        #help-msg-area {
            display: none; color: var(--main-yellow); 
            font-family: 'Nanum Gothic Coding', monospace; font-size: var(--base-font-size);
            text-align: right; white-space: nowrap;
        }

        #final-msg-area {
            display: none; color: var(--main-yellow); 
            font-family: 'Nanum Gothic Coding', monospace; font-size: var(--base-font-size);
            text-align: right; white-space: nowrap; cursor: pointer; text-decoration: none;
        }

        #save-icon-btn {
            display: none; width: 24px; height: 24px; cursor: pointer;
            fill: white; transition: fill 0.3s; pointer-events: auto; 
        }
        #save-icon-btn:hover { fill: var(--main-yellow); }

        .hamburger-icon { 
            width: 30px; height: auto; display: flex; flex-direction: column; justify-content: center; 
            cursor: pointer; z-index: 2000; pointer-events: auto;
        }
        .hamburger-icon img { width: 100%; height: auto; display: block; transition: all 0.3s; }

        #info-popup {
            display: none; 
            position: fixed; 
            top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 70vw; 
            max-width: 1600px;
            height: auto;
            max-height: 90vh;
            background-color: black; 
            border: 0.5px solid white;
            padding: 50px; 
            z-index: 2100;
            color: white; 
            font-family: 'Wanted Sans Variable', 'Wanted Sans', sans-serif; 
            font-weight: 700; 
            box-sizing: border-box;
            overflow-y: auto;
        }

        #popup-close-btn { position: absolute; top: 25px; right: 30px; font-family: sans-serif; font-size: 30px; cursor: pointer; color: white; }
        
        .popup-header-container { display: block; margin-bottom: 30px; min-height: 30px; }
        .popup-title-text { font-family: 'Nanum Gothic Coding', monospace; font-size: 18px; color: var(--main-yellow); display: block; font-weight: bold; }
        .popup-title-img { max-height: 28px; width: auto; display: none; }

        .popup-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr); 
            gap: 60px; 
            width: 100%;
        }

        .popup-col {
            font-size: 14px;
            line-height: 1.7;
            text-align: left;
            color: white;
            word-break: keep-all; 
        }

        .popup-col b {
            color: var(--main-yellow);
            font-weight: 700;
            display: inline-block;
            margin-bottom: 10px;
            font-size: 14px;
        }

        #soundcloud-container {
            position: fixed; top: -9999px; left: -9999px; width: 1px; height: 1px;
            opacity: 0; pointer-events: none;
        }

    </style>
</head>
<body>

    <svg id="canvas-container" xmlns="http://www.w3.org/2000/svg"></svg>
    
    <div id="visualizer-layer"><canvas id="oscilloscope"></canvas></div>
    <div id="collage-layer"><canvas id="collage-canvas"></canvas></div>
    <div id="nasa-image-layer"></div>
    
    <button id="startBtn">Click here to message with an alien!</button>

    <div id="content-layer">
        <div id="messageLog"></div>
        <div id="footer-bar">
            <div id="input-area-left">
                <span id="blinking-cursor">/</span>
                <input type="text" id="messageInput" placeholder="Type your message and click Enter." autocomplete="off">
            </div>
            <div id="ui-area-right">
                <div id="rotating-text-area"></div>
                <div id="help-msg-area">Randomly insert the images into 3 kinds of triangles for message input.</div>
                
                <div id="final-msg-area" onclick="playBtnSound(); setTimeout(() => location.reload(), 500)">Click here to remessage with aliens forever.</div>
                <svg id="save-icon-btn" viewBox="0 0 24 24">
                    <path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/>
                </svg>
                
                <div class="hamburger-icon" id="menuBtn">
                    <img src="icon2.png" alt="Menu" id="menu-icon-img">
                </div>
            </div>
        </div>
    </div>

    <div id="info-popup">
        <div id="popup-close-btn">✕</div>
        
        <div class="popup-content">
            <div class="popup-header-container">
                <span id="popup-text-title" class="popup-title-text">Golden Indexed</span>
                <img src="title.png" id="popup-img-title" class="popup-title-img" alt="Golden Indexed Title">
            </div>
            
            <div class="popup-grid">
                <div class="popup-col">
                    <b>기호를 활용해 외계인과 소통할 수 있을까?</b><br>
                    인간의 읽기와 쓰기 체계 중 하나인 기호가 과연 상호작용이 가능한지를 실험해보는 도구 형태의 웹사이트이다.<br><br>
                    도구적 형태로 간접 소통해봄으로써 어쩌면 외계인과 소통은 불가능할지도 모르는 전제 하에 인간의 상상력의 한계를 넘어 상상해보고, 인간 문명 속 무모한 낭만과 영감의 시너지를 주고자 한다.<br><br>
                    ⓒ 김채린. 2025.<br>
                    e.chaerinkim@gmail.com
                </div>

                <div class="popup-col">
                    <b>『디자인 정치학』 뤼번 파터르, 고트, 2022.</b><br>
                    “1977년 미국항공우주국 NASA에서 보이저 1호, 2호에 지구의 정보를 담은 음반 ‘골드 레코드'를 만들어 외계 생명체와 소통하고자 하였다. 외계인들이 오랜 시간 연구하면 메시지를 해독할지 모른다는 것이 당시 발상이었다.” <br> - 4장 ‘외계인부터 선조까지’
                    <br><br>
                    관련 내용을 읽으며 ‘그럼에도 불구하고 외계인과 과연 소통할 수 있을까? 소통할 수 있을 것이라는 착각과 왜곡된, 그럴 것이라는 믿음 때문에 소통해보려고 하는 무모한 도전이지 않을까?’ 라는 질문을 탐구해보기 위해 이 프로젝트가 시작되었다. 또한 어쩌면 NASA가 보낸 언어는 인간이 생각한 읽기와 쓰기 체계 속 언어가 아닐지도 모르고, 과거의 외계인과 소통할 수 있을지도, 월등한 문명을 가진 외계인에게 멸망의 신호를 보내고 있는 것일지 모르는 무모한 탐구가 과연 올바른, 또는 왜곡된, 잘못된 시선인지 도구적 형태로 알아보고자 한다.

                    <br><br><br> <b>책 속 교훈</b><br>
                    "우주에서 무슨 일이 일어나든, 알 수 없는 운명이 무엇이든, 우리 문명이 가장 큰 꿈을 꾸었던 최고점을 나타낸다고 생각한다."
                    <br><br>
                    “생경한 외계인에게 전달할 메시지를 디자인하는 것은 본질적으로 불가능하다. 그러기 위해서는 철저하게 인간 바깥에서 생각을 하고 상상력의 한계를 넘어 상상해야 할테니 말이다. 그리고 이것이 사람들에게 계속 꿈을 꾸도록 하는 본보기가 되고, 영감이 되기를 바란다.” <br> - 존 런버그, 골든 레코드 디자인 디렉터

                    <br><br><br> <b>도구의 기능</b><br>
                    이 웹사이트는 다음과 같은 시각적 스토리텔링 기반으로 제작되었다. NASA의 골든 레코드 속 115가지 인간의 사진들은 모두 소리의 파형으로 담겨져 있다. 이것을 모티브 삼아 웹사이트 속 ‘오디오 비주얼라이저’ 라는 소리의 진동을 통해 움직이는 3가지 삼각형을 구현하였다. 삼각형이 이미지를 수집하면서 점점 원형으로 변환하는 과정이 나타나는데 여기서 삼각형은 ‘인간’을 표현하고, 원형은 ‘외계인’을 표현한다. 즉 인간이 외계인에게 메시지를 보내고 있다는 간접적 시각 형태를 보여준다. 삼각형이 ‘인간’인 이유는 인간에게는 시대, 시제, 기호가 담겨있기에 모서리가 있는 삼각형으로 단순화 한 것이다. 반대로 원형이 ‘외계인’인 이유는 외계인에게는 시대, 시제, 기호가 없을 것이라는 상상이자 무모한 추측으로 시각화해본 것이다. 다시 말해 외계인에게는 어쩌면 과거와 현재가 연결되어 있고, 그들의 시선에는 모든 시대와 시제가 일직선으로 보일지도 모른다는 시각적 추측을 표현한 것이다.
                    <br><br>
                    결론적으로 이 웹사이트는 미래에 상상력을 무모한 도구로써 표현해본 것이지만 그 안에 시각적 요소는 모든 인간과 외계인의 과거, 현재, 미래가 연결되도록 표현하였다. 인간의 읽기와 쓰기 체계 중 하나인 기호를 활용해 외계인과 간접적으로 소통해보는 것을 유도하였지만 이러한 무모한 도전은 어쩌면 인간 문명에 새로운 영감과 낭만을 마련하고, 더불어 외계인과의 소통이 과학적으로 가능한지 다시 한번 생각해볼 수 있는 계기를 제공하기도 한다.
                </div>
            </div>
        </div>
    </div>
    
    <div id="soundcloud-container"></div>

    <script>
        const sfxBtn = new Audio('button.mp3');
        const sfxMessage = new Audio('message.mp3');
        const bgmList = ['space1.mp3', 'space2.mp3', 'voyager.mp3'];
        let currentBgmIndex = 0;
        let bgmAudio = new Audio();
        let isCollageMode = false;

        function playBtnSound() {
            sfxBtn.currentTime = 0; 
            sfxBtn.play().catch(e => console.log('Sound play blocked:', e));
        }

        function playNextBgm() {
            if (isCollageMode) return;
            bgmAudio.src = bgmList[currentBgmIndex];
            bgmAudio.play().catch(e => console.log('BGM play blocked:', e));
            currentBgmIndex = (currentBgmIndex + 1) % bgmList.length;
        }
        
        bgmAudio.addEventListener('ended', playNextBgm);

        const soundCloudUrls = [
            "https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/tracks/soundcloud%253Atracks%253A1669467051&color=%23ff5500&auto_play=false&hide_related=false&show_comments=true&show_user=true&show_reposts=false&show_teaser=true&visual=true",
            "https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/tracks/soundcloud%253Atracks%253A1669466991&color=%23ff5500&auto_play=false&hide_related=false&show_comments=true&show_user=true&show_reposts=false&show_teaser=true&visual=true",
            "https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/tracks/soundcloud%253Atracks%253A1669466895&color=%23ff5500&auto_play=false&hide_related=false&show_comments=true&show_user=true&show_reposts=false&show_teaser=true&visual=true",
            "https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/tracks/soundcloud%253Atracks%253A1669466811&color=%23ff5500&auto_play=false&hide_related=false&show_comments=true&show_user=true&show_reposts=false&show_teaser=true&visual=true",
            "https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/tracks/soundcloud%253Atracks%253A1669466721&color=%23ff5500&auto_play=false&hide_related=false&show_comments=true&show_user=true&show_reposts=false&show_teaser=true&visual=true",
            "https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/tracks/soundcloud%253Atracks%253A1669466583&color=%23ff5500&auto_play=false&hide_related=false&show_comments=true&show_user=true&show_reposts=false&show_teaser=true&visual=true",
            "https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/tracks/soundcloud%253Atracks%253A1669466466&color=%23ff5500&auto_play=false&hide_related=false&show_comments=true&show_user=true&show_reposts=false&show_teaser=true&visual=true",
            "https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/tracks/soundcloud%253Atracks%253A1669466421&color=%23ff5500&auto_play=false&hide_related=false&show_comments=true&show_user=true&show_reposts=false&show_teaser=true&visual=true",
            "https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/tracks/soundcloud%253Atracks%253A1669466322&color=%23ff5500&auto_play=false&hide_related=false&show_comments=true&show_user=true&show_reposts=false&show_teaser=true&visual=true",
            "https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/tracks/soundcloud%253Atracks%253A1669466304&color=%23ff5500&auto_play=false&hide_related=false&show_comments=true&show_user=true&show_reposts=false&show_teaser=true&visual=true",
            "https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/tracks/soundcloud%253Atracks%253A1669466262&color=%23ff5500&auto_play=false&hide_related=false&show_comments=true&show_user=true&show_reposts=false&show_teaser=true&visual=true"
        ];

        document.addEventListener("DOMContentLoaded", () => {
            const INITIAL_SPACING = 350; 
            const HITBOX_RADIUS = 160; 
            const MERGE_DURATION = 3200; 
            const IDLE_LIMIT = 15000; 
            const STORAGE_KEY = 'alien_comm_log_persistent';

            let currentSpacing = INITIAL_SPACING; 
            let droppedImageCount = 0; 
            let isMerging = false; 
            let mergeStartTime = null; 
            let flowOffset = 0; 
            const droppedImages = { 0: [], 1: [], 2: [] };

            let idleTimeout;
            let isHelpMode = false;
            let helpInterval;
            let hasInteracted = false; 

            const txtArea = document.getElementById('rotating-text-area');
            const helpArea = document.getElementById('help-msg-area');

            const svgContainer = document.getElementById('canvas-container');
            const setArtCount = 20; const artRadius = 10; 

            function easeInOutQuintArt(x) { return x < 0.5 ? 16 * x * x * x * x * x : 1 - Math.pow(-2 * x + 2, 5) / 2; }
            
            class ArtSet {
                constructor(svg, w, h) {
                    this.svg = svg; this.w = w; this.h = h; this.ns = "http://www.w3.org/2000/svg";
                    this.g = document.createElementNS(this.ns, "g"); this.g.classList.add("art-shape");
                    this.line = document.createElementNS(this.ns, "line");
                    this.c1 = document.createElementNS(this.ns, "circle"); this.c2 = document.createElementNS(this.ns, "circle");
                    this.c1.setAttribute("r", artRadius); this.c2.setAttribute("r", artRadius);
                    this.g.appendChild(this.line); this.g.appendChild(this.c1); this.g.appendChild(this.c2);
                    this.svg.appendChild(this.g); this.init();
                }
                init() {
                    this.y1 = artRadius; this.y2 = this.h - artRadius;
                    this.currX1 = Math.random() * (this.w - 20) + 10; this.currX2 = Math.random() * (this.w - 20) + 10;
                    this.startX1 = this.currX1; this.startX2 = this.currX2;
                    this.targetX1 = Math.random() * (this.w - 20) + 10; this.targetX2 = Math.random() * (this.w - 20) + 10;
                    this.startTime = null;
                }
                update(t) {
                    if (!this.startTime) this.startTime = t;
                    const p = Math.min((t - this.startTime) / 6000, 1);
                    const ep = easeInOutQuintArt(p);
                    this.currX1 = this.startX1 + (this.targetX1 - this.startX1) * ep;
                    this.currX2 = this.startX2 + (this.targetX2 - this.startX2) * ep;
                    if (p >= 1) { 
                        this.startTime = t; this.startX1 = this.currX1; this.startX2 = this.currX2; 
                        this.targetX1 = Math.random() * (this.w-20)+10; this.targetX2 = Math.random() * (this.w-20)+10; 
                    }
                    this.draw();
                }
                draw() {
                    this.c1.setAttribute("cx", this.currX1); this.c1.setAttribute("cy", this.y1);
                    this.c2.setAttribute("cx", this.currX2); this.c2.setAttribute("cy", this.y2);
                    const a = Math.atan2(this.y2 - this.y1, this.currX2 - this.currX1);
                    this.line.setAttribute("x1", this.currX1 + 10 * Math.cos(a)); this.line.setAttribute("y1", this.y1 + 10 * Math.sin(a));
                    this.line.setAttribute("x2", this.currX2 - 10 * Math.cos(a)); this.line.setAttribute("y2", this.y2 - 10 * Math.sin(a));
                }
            }
            
            let artSets = [];
            function initArt() { 
                svgContainer.innerHTML = ''; artSets = []; 
                for(let i=0; i<setArtCount; i++) artSets.push(new ArtSet(svgContainer, window.innerWidth, window.innerHeight)); 
                requestAnimationFrame(animateArt); 
            }
            function animateArt(t) { artSets.forEach(s => s.update(t)); requestAnimationFrame(animateArt); }
            initArt(); window.addEventListener('resize', initArt);

            function resetIdleTimer() {
                if (hasInteracted || isMerging) return;
                clearTimeout(idleTimeout);
                if (!isHelpMode) {
                    idleTimeout = setTimeout(showHelpMode, IDLE_LIMIT);
                }
            }

            function showHelpMode() {
                if (hasInteracted || isMerging) return;
                isHelpMode = true;
                clearInterval(textInterval);
                txtArea.style.display = 'none';
                helpArea.style.display = 'block';
                let visible = true;
                helpArea.style.opacity = '1';
                helpInterval = setInterval(() => {
                    visible = !visible;
                    helpArea.style.opacity = visible ? '1' : '0';
                }, 500);
            }

            function endHelpMode() {
                if (!isHelpMode) return; 
                isHelpMode = false;
                hasInteracted = true; 
                clearInterval(helpInterval);
                helpArea.style.display = 'none';
                txtArea.style.display = 'block';
                txtArea.style.opacity = '1'; 
                rotateText();
                textInterval = setInterval(rotateText, 5000);
            }

            window.addEventListener('mousemove', resetIdleTimer);
            window.addEventListener('mousedown', resetIdleTimer);
            resetIdleTimer();

            const imageLayer = document.getElementById('nasa-image-layer');
            const totalImages = 55; 
            const batchSize = 7;    

            function spawnImageBatch() {
                imageLayer.innerHTML = ''; 
                const placedRects = []; 
                const imgWidthVW = 7.5; 
                const vwToPx = window.innerWidth / 100;
                const imgSizePx = imgWidthVW * vwToPx * 1.5; 

                const selectedIndices = new Set();
                while(selectedIndices.size < batchSize) {
                    selectedIndices.add(Math.floor(Math.random() * totalImages) + 1);
                }

                selectedIndices.forEach(randomIdx => {
                    const img = document.createElement('img');
                    img.src = `nasa${randomIdx}.jpg`;
                    img.classList.add('nasa-popup-img');
                    
                    let randomX, randomY;
                    let overlapping = true;
                    let attempts = 0;

                    while (overlapping && attempts < 100) {
                        overlapping = false;
                        randomX = Math.random() * (window.innerWidth - imgSizePx);
                        randomY = Math.random() * (window.innerHeight - imgSizePx);

                        for (const rect of placedRects) {
                            const dx = randomX - rect.x;
                            const dy = randomY - rect.y;
                            if (Math.sqrt(dx*dx + dy*dy) < imgSizePx) {
                                overlapping = true; break;
                            }
                        }
                        attempts++;
                    }

                    placedRects.push({x: randomX, y: randomY});
                    img.style.left = `${randomX}px`; img.style.top = `${randomY}px`;
                    img.style.transform = `rotate(${(Math.random() - 0.5) * 60}deg)`;

                    setupDragAndDrop(img);
                    imageLayer.appendChild(img);
                });
            }

            function setupDragAndDrop(img) {
                let isDragging = false;
                let dragOffsetX = 0;
                let dragOffsetY = 0;
                
                const onMouseDown = (e) => {
                    if (e.button !== 0) return; 
                    e.preventDefault(); 
                    isDragging = true;
                    img.classList.add('dragging');
                    const rect = img.getBoundingClientRect();
                    dragOffsetX = e.clientX - rect.left;
                    dragOffsetY = e.clientY - rect.top;
                };

                const onMouseMove = (e) => {
                    if (!isDragging) return;
                    e.preventDefault();
                    img.style.left = `${e.clientX - dragOffsetX}px`;
                    img.style.top = `${e.clientY - dragOffsetY}px`;
                };

                const onMouseUp = (e) => {
                    if (!isDragging) return;
                    isDragging = false;
                    img.classList.remove('dragging');

                    if (!audioOn) {
                        img.style.transition = 'opacity 1s ease-in-out'; 
                        return;
                    }

                    const cx = window.innerWidth / 2; 
                    const cy = window.innerHeight / 2;
                    const targets = [
                        { x: cx - currentSpacing, y: cy, id: 0 }, 
                        { x: cx, y: cy, id: 1 },                  
                        { x: cx + currentSpacing, y: cy, id: 2 }  
                    ];
                    
                    let hitTarget = null;
                    for (const t of targets) {
                        const dist = Math.sqrt(Math.pow(e.clientX - t.x, 2) + Math.pow(e.clientY - t.y, 2));
                        if (dist < HITBOX_RADIUS) { 
                            hitTarget = t; break; 
                        }
                    }

                    if (hitTarget) {
                        playBtnSound();

                        if (isHelpMode) endHelpMode();
                        hasInteracted = true; 
                        clearTimeout(idleTimeout);

                        droppedImages[hitTarget.id].push(img.src);
                        img.style.transition = 'all 0.3s ease-out';
                        img.style.left = `${hitTarget.x - img.offsetWidth/2}px`;
                        img.style.top = `${hitTarget.y - img.offsetHeight/2}px`;
                        requestAnimationFrame(() => { img.classList.add('pop-vanish'); });
                        setTimeout(() => { img.remove(); }, 300);

                        droppedImageCount++;
                        if (droppedImageCount >= batchSize) {
                            startMergingSequence();
                        }
                    } else {
                        img.style.transition = 'opacity 1s ease-in-out'; 
                    }
                };

                img.addEventListener('mousedown', onMouseDown);
                window.addEventListener('mousemove', onMouseMove);
                window.addEventListener('mouseup', onMouseUp);
            }
            
            function startMergingSequence() {
                isMerging = true;
                mergeStartTime = null; 
                triggerSpecialTextMode();
            }
            
            spawnImageBatch(); 

            const canvas = document.getElementById('oscilloscope'); const ctx = canvas.getContext('2d');
            const startBtn = document.getElementById('startBtn'); const res = 2;
            function resizeC() { canvas.width = window.innerWidth * res; canvas.height = window.innerHeight * res; ctx.scale(res, res); }
            resizeC(); window.addEventListener('resize', resizeC);
            let actx, anl, dArray, bufLen, audioOn = false;

            startBtn.addEventListener('click', async () => {
                playBtnSound();
                playNextBgm();

                startBtn.style.display = 'none'; audioOn = true;
                actx = new (window.AudioContext || window.webkitAudioContext)();
                try {
                    const strm = await navigator.mediaDevices.getUserMedia({ audio: true });
                    const src = actx.createMediaStreamSource(strm);
                    anl = actx.createAnalyser(); anl.fftSize = 2048; anl.smoothingTimeConstant = 0.85;
                    src.connect(anl); bufLen = anl.frequencyBinCount; dArray = new Uint8Array(bufLen);
                    drawVis();
                } catch (e) { console.error(e); alert("마이크 권한 필요"); }
            });

            function easeInOutQuint(x) { return x < 0.5 ? 16 * x * x * x * x * x : 1 - Math.pow(-2 * x + 2, 5) / 2; }

            function drawVis() {
                if (!audioOn) return; 
                requestAnimationFrame(drawVis);
                anl.getByteTimeDomainData(dArray);
                ctx.clearRect(0, 0, canvas.width/res, canvas.height/res);
                
                flowOffset -= 0.3; 

                let morphValue = 0; 
                if (isMerging) {
                    if (!mergeStartTime) mergeStartTime = performance.now();
                    const elapsed = performance.now() - mergeStartTime;
                    let progress = Math.min(elapsed / MERGE_DURATION, 1);
                    const easedProgress = easeInOutQuint(progress);
                    currentSpacing = INITIAL_SPACING * (1 - easedProgress); 
                    morphValue = easedProgress; 
                }

                const cx = window.innerWidth/2, cy = window.innerHeight/2;
                drawMorphShape(cx - currentSpacing, cy, 150, 0, morphValue); 
                drawMorphShape(cx, cy, 150, 1, morphValue); 
                drawMorphShape(cx + currentSpacing, cy, 150, 2, morphValue);
            }

            function drawMorphShape(cx, cy, r, type, morphValue) {
                let vol = 0; for(let i=0; i<dArray.length; i++) vol += Math.abs(dArray[i]-128); vol /= dArray.length;
                let sc = 1 + (vol/128) * (type===1?0.3:(type===0?0.1:0.05));
                
                ctx.save(); ctx.translate(cx, cy); ctx.scale(sc, sc); ctx.translate(-cx, -cy);

                const basePoints = [];
                const points = [];
                
                const triPts = []; 
                for(let k=0; k<3; k++) {
                    triPts.push({ x: cx + r * Math.cos(-Math.PI/2 + k*2*Math.PI/3), y: cy + r * Math.sin(-Math.PI/2 + k*2*Math.PI/3) });
                }
                const step = Math.ceil(bufLen/300);
                for(let i=0; i<bufLen; i+=step) {
                    const t = i/bufLen;
                    const si = Math.floor(t*3)%3; const nsi = (si+1)%3; const st = (t*3)%1;
                    
                    const triX = triPts[si].x + (triPts[nsi].x - triPts[si].x)*st;
                    const triY = triPts[si].y + (triPts[nsi].y - triPts[si].y)*st;
                    
                    const circleAngle = -Math.PI/2 + (t * 2 * Math.PI);
                    const circleX = cx + r * Math.cos(circleAngle);
                    const circleY = cy + r * Math.sin(circleAngle);
                    
                    const basePathX = triX * (1 - morphValue) + circleX * morphValue;
                    const basePathY = triY * (1 - morphValue) + circleY * morphValue;
                    
                    basePoints.push({x: basePathX, y: basePathY});

                    let rawVal = 0;
                    if (type === 0) rawVal = (dArray[i] / 128.0) - 1.0;
                    else if (type === 1) rawVal = -((dArray[bufLen - 1 - i] / 128.0) - 1.0) * 1.2;
                    else rawVal = (dArray[(i * 2) % bufLen] / 128.0) - 1.0;
                    
                    const angleFromCenter = Math.atan2(basePathY - cy, basePathX - cx);
                    const displacement = rawVal * 60; 
                    const fx = basePathX + Math.cos(angleFromCenter) * displacement;
                    const fy = basePathY + Math.sin(angleFromCenter) * displacement;
                    
                    points.push({x: fx, y: fy});
                }

                ctx.beginPath();
                ctx.lineWidth = 20; 
                ctx.setLineDash([25, 35]); 
                ctx.strokeStyle = '#FBCD0D'; 
                ctx.lineJoin = 'round'; ctx.lineCap = 'round'; 
                
                if(points.length > 0) {
                    ctx.moveTo(points[0].x, points[0].y);
                    for(let i=1; i<points.length; i++) ctx.lineTo(points[i].x, points[i].y);
                    ctx.lineTo(points[0].x, points[0].y);
                }
                ctx.stroke();

                ctx.setLineDash([]); 
                ctx.lineWidth = 20; 
                ctx.beginPath();

                const totalPts = basePoints.length;
                const tickSpacing = 50; 
                const phaseShift = Math.floor(totalPts * 0.17); 

                for(let i=0; i<totalPts; i++) {
                    const movingIndex = Math.floor(i - flowOffset - phaseShift);
                    const patternPos = ((movingIndex % tickSpacing) + tickSpacing) % tickSpacing;
                    const groupIndex = Math.floor(movingIndex / tickSpacing);

                    let shouldDraw = false;
                    if (patternPos === 0) shouldDraw = true;
                    if (groupIndex % 2 === 0 && patternPos === 20) shouldDraw = true;

                    if (shouldDraw) {
                        const p1 = basePoints[i];
                        const p2 = basePoints[(i+1) % totalPts];
                        const dx = p2.x - p1.x; const dy = p2.y - p1.y;
                        const angle = Math.atan2(dy, dx);
                        const perpAngle = angle - Math.PI / 2; 

                        const tickLen = 18; 
                        const tx = p1.x + Math.cos(perpAngle) * tickLen;
                        const ty = p1.y + Math.sin(perpAngle) * tickLen;

                        ctx.moveTo(p1.x, p1.y);
                        ctx.lineTo(tx, ty);
                    }
                }
                ctx.stroke();
                ctx.restore();
            }

            const msgIn = document.getElementById('messageInput'); 
            const msgLog = document.getElementById('messageLog'); 
            const cursor = document.getElementById('blinking-cursor');
            
            setInterval(() => { cursor.style.opacity = cursor.style.opacity === '0' ? '1' : '0'; }, 500);
            
            function toBin(n) { return n.toString(2); }
            function getBinTime() { const n = new Date(); return `${toBin(n.getFullYear())} ${toBin(n.getMonth()+1)} ${toBin(n.getDate())} ${toBin(n.getHours())} ${toBin(n.getMinutes())} ${toBin(n.getSeconds())}`; }
            
            function appendMsgToDOM(t, txt) {
                const d = document.createElement('div'); d.className = 'message-entry';
                d.innerHTML = `<span class="binary-date">${t}</span><span class="message-text">${txt}</span>`;
                msgLog.appendChild(d); 
                msgLog.scrollTop = msgLog.scrollHeight;
            }

            function addMsg(t, txt) {
                appendMsgToDOM(t, txt);
                const savedData = JSON.parse(localStorage.getItem(STORAGE_KEY) || '[]');
                savedData.push({ time: t, text: txt });
                localStorage.setItem(STORAGE_KEY, JSON.stringify(savedData));
            }

            const existingData = localStorage.getItem(STORAGE_KEY);
            if (existingData) {
                const parsedData = JSON.parse(existingData);
                parsedData.forEach(item => {
                    appendMsgToDOM(item.time, item.text);
                });
            }

            msgIn.addEventListener('keydown', (e) => {
                if(e.key === 'Enter' && msgIn.value.trim()) {
                    playBtnSound();
                    addMsg(getBinTime(), msgIn.value.trim()); msgIn.value = '';
                }
            });

            const menuBtn = document.getElementById('menuBtn');
            const menuIconImg = document.getElementById('menu-icon-img'); 
            const infoPopup = document.getElementById('info-popup');
            const closeBtn = document.getElementById('popup-close-btn');
            
            menuBtn.addEventListener('mouseenter', () => {
                menuIconImg.src = 'icon1.png';
            });
            menuBtn.addEventListener('mouseleave', () => {
                menuIconImg.src = 'icon2.png';
            });

            menuBtn.addEventListener('click', (e) => {
                playBtnSound();
                e.stopPropagation(); 
                if (infoPopup.style.display === 'block') {
                    infoPopup.style.display = 'none';
                } else {
                    infoPopup.style.display = 'block';
                    menuIconImg.src = 'icon1.png';
                }
            });

            closeBtn.addEventListener('click', (e) => {
                playBtnSound();
                e.stopPropagation();
                infoPopup.style.display = 'none';
            });

            const titleText = document.getElementById('popup-text-title');
            const titleImg = document.getElementById('popup-img-title');
            let showTitleImg = false; 

            setInterval(() => {
                showTitleImg = !showTitleImg; 
                if (showTitleImg) {
                    titleText.style.display = 'none';
                    titleImg.style.display = 'block';
                } else {
                    titleText.style.display = 'block';
                    titleImg.style.display = 'none';
                }
            }, 5000);

            const texts = [
                "Whatever happens in space, whatever the unknown fate,",
                "Human believe this represents the culmination of our civilization's wildest dreams.",
                "This might be inherently impossible for messaging an alien.",
                "But we still need to think radically outside the box and imagine",
                "beyond the limits of our imagination.",
                "This would be a bold challenge and a beginning.",
                "And this would be new example and inspiration to others throughout",
                "time and across all eras, encouraging them to continue to dream."
            ];
            let txtIdx = 0;
            let textInterval = null; 

            function rotateText() {
                txtArea.style.opacity = '0';
                setTimeout(() => {
                    txtArea.innerText = texts[txtIdx];
                    txtIdx = (txtIdx + 1) % texts.length;
                    txtArea.style.opacity = '1';
                }, 1000); 
            }
            rotateText();
            textInterval = setInterval(rotateText, 5000);

            function triggerSpecialTextMode() {
                clearInterval(textInterval);
                txtArea.style.opacity = '0';

                if(isHelpMode) endHelpMode(); 
                clearInterval(textInterval); 
                helpArea.style.display = 'none';

                setTimeout(() => {
                    sfxMessage.currentTime = 0;
                    sfxMessage.play().catch(e => console.log('Message sound blocked:', e));

                    const specialMsg = "Ready to communicate with aliens. Typing a message...";
                    txtArea.innerText = specialMsg;
                    txtArea.style.color = "var(--main-yellow)"; 
                    txtArea.style.textDecoration = "none";

                    let blinkState = true;
                    txtArea.style.opacity = '1';

                    const blinkInterval = setInterval(() => {
                        blinkState = !blinkState;
                        txtArea.style.opacity = blinkState ? '1' : '0';
                    }, 500);

                    setTimeout(() => {
                        clearInterval(blinkInterval);
                        txtArea.style.opacity = '0'; 
                        setTimeout(() => {
                            initCollageParticles(); 
                        }, 500);
                    }, 10000);

                }, 1000);
            }

            let pCanvas, pCtx;
            let particles = [];
            const GAP = 4; 
            let pTime = 0;
            let collageAnimationId;

            class Particle {
                constructor(x, y, color, mode) {
                    this.ox = x; this.oy = y;
                    this.x = x + (Math.random() - 0.5) * 500; 
                    this.y = y + (Math.random() - 0.5) * 500;
                    this.color = color;
                    this.mode = mode; 
                    this.ease = 0.08;
                }
                
                update(width, height) {
                    let tx = this.ox, ty = this.oy;
                    const cx = this.ox; const cy = this.oy;
                    const screenCx = width / 2; const screenCy = height / 2;

                    if (this.mode === 1) { 
                        tx = cx + Math.sin(cy * 0.01 + pTime) * 20; ty = cy + Math.cos(cx * 0.01 + pTime) * 20;
                    } else if (this.mode === 2) { 
                        const dx = cx - screenCx; const dy = cy - screenCy;
                        const angle = Math.atan2(dy, dx); const r = Math.sqrt(dx*dx + dy*dy);
                        const twist = r * 0.005 - pTime * 2;
                        tx = screenCx + Math.cos(angle + twist) * r; ty = screenCy + Math.sin(angle + twist) * r;
                    } else if (this.mode === 3) { 
                        tx = cx + Math.sin(cy * 0.05 + pTime * 3) * 50;
                    } else if (this.mode === 4) { 
                        const pulse = Math.sin(pTime * 2) * 50;
                        const dx = cx - screenCx; const dy = cy - screenCy;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        if(dist < 200 + pulse) { tx += (Math.random()-0.5) * 50; ty += (Math.random()-0.5) * 50; }
                    } else if (this.mode === 5) { 
                        const flow = (pTime * 50) % (height + 100);
                        const noise = Math.sin(cx * 0.05) * 10;
                        if (cy + flow + noise > height) ty = (cy + flow + noise) - height; else ty = cy + flow + noise; 
                    } else if (this.mode === 6) { 
                        if(Math.random() > 0.98) tx = cx + (Math.random()-0.5) * 100;
                    } else if (this.mode === 7) { 
                        const i = (this.ox * 0.01 + this.oy * 0.01);
                        const r = 20 + (pTime * 10 % 100);
                        tx = cx + Math.cos(i + pTime) * r; ty = cy + Math.sin(i + pTime) * r;
                    } else if (this.mode === 8) { 
                        ty = cy + Math.sin(cx * 0.05 + pTime * 3) * 30;
                    } else if (this.mode === 9) { 
                        tx = cx + Math.sin(pTime * 5 + this.oy) * 10; ty = cy + Math.cos(pTime * 5 + this.ox) * 10;
                    } else if (this.mode === 10) { 
                        tx = cx + (Math.random()-0.5) * 20; ty = cy + (Math.random()-0.5) * 20;
                    }

                    this.x += (tx - this.x) * this.ease;
                    this.y += (ty - this.y) * this.ease;
                }

                draw(ctx) {
                    ctx.fillStyle = this.color;
                    ctx.fillRect(this.x, this.y, GAP, GAP);
                }
            }

            function initCollageParticles() {
                isCollageMode = true;
                bgmAudio.pause();

                const scContainer = document.getElementById('soundcloud-container');
                const randomUrl = soundCloudUrls[Math.floor(Math.random() * soundCloudUrls.length)];
                const autoPlayUrl = randomUrl.replace('auto_play=false', 'auto_play=true');
                
                scContainer.innerHTML = `<iframe width="100%" height="300" scrolling="no" frameborder="no" allow="autoplay" src="${autoPlayUrl}"></iframe>`;


                document.getElementById('visualizer-layer').style.display = 'none';
                document.getElementById('collage-layer').style.display = 'block';
                
                const rotateArea = document.getElementById('rotating-text-area');
                const finalMsg = document.getElementById('final-msg-area');
                const saveIcon = document.getElementById('save-icon-btn');

                rotateArea.style.display = 'none'; 
                finalMsg.style.display = 'block';
                saveIcon.style.display = 'block';

                let finalBlink = true;
                setInterval(() => {
                    finalBlink = !finalBlink;
                    finalMsg.style.opacity = finalBlink ? '1' : '0';
                }, 500);

                pCanvas = document.getElementById('collage-canvas');
                pCtx = pCanvas.getContext('2d');
                pCanvas.width = window.innerWidth;
                pCanvas.height = window.innerHeight;

                particles = [];
                
                const rowHeights = [window.innerHeight * 0.2, window.innerHeight * 0.5, window.innerHeight * 0.8];
                const imgSize = 200; 
                const promises = [];

                for(let r=0; r<3; r++) { 
                    const imgs = droppedImages[r];
                    if (imgs.length === 0) continue; 
                    const startX = (window.innerWidth - (imgs.length * imgSize)) / 2;

                    imgs.forEach((src, idx) => {
                        const p = new Promise((resolve) => {
                            const img = new Image();
                            img.src = src;
                            
                            img.onload = () => {
                                const tmpC = document.createElement('canvas');
                                tmpC.width = imgSize; tmpC.height = imgSize;
                                const tmpCtx = tmpC.getContext('2d');
                                tmpCtx.drawImage(img, 0, 0, imgSize, imgSize);
                                
                                try {
                                    const data = tmpCtx.getImageData(0, 0, imgSize, imgSize).data;
                                    
                                    let mode;
                                    if(r === 0) mode = Math.floor(Math.random() * 3) + 1; 
                                    else if(r === 1) mode = Math.floor(Math.random() * 3) + 4; 
                                    else mode = Math.floor(Math.random() * 4) + 7; 

                                    let baseDrawX = startX + idx * (imgSize - 50);
                                    let baseDrawY = rowHeights[r] - imgSize/2;

                                    const randomShiftX = (Math.random() - 0.5) * 50; 
                                    const randomShiftY = (Math.random() - 0.5) * 50;

                                    const drawX = baseDrawX + randomShiftX;
                                    const drawY = baseDrawY + randomShiftY;

                                    for(let y=0; y<imgSize; y+=GAP) {
                                        for(let x=0; x<imgSize; x+=GAP) {
                                            const i = (y * imgSize + x) * 4;
                                            const a = data[i+3];
                                            if(a > 50) { 
                                                const color = `rgb(${data[i]},${data[i+1]},${data[i+2]})`;
                                                particles.push(new Particle(drawX + x, drawY + y, color, mode));
                                            }
                                        }
                                    }
                                } catch(e) { 
                                    console.warn("캔버스 보안 오류: 로컬 서버(Live Server)에서 실행해주세요.", e); 
                                }
                                resolve();
                            };
                            img.onerror = () => {
                                console.warn("이미지 로드 실패:", src);
                                resolve(); 
                            };
                        });
                        promises.push(p);
                    });
                }

                Promise.all(promises).then(() => { 
                    if(particles.length === 0) {
                        alert("보안 문제로 파티클을 생성할 수 없습니다. 파일을 서버 환경(Live Server 등)에서 실행해주세요.");
                    }
                    animateCollage(); 
                });

                saveIcon.addEventListener('click', () => {
                    playBtnSound();
                    const contentLayer = document.getElementById('content-layer');
                    const startBtn = document.getElementById('startBtn');
                    const infoPopup = document.getElementById('info-popup');

                    contentLayer.style.display = 'none';
                    if(startBtn) startBtn.style.display = 'none';
                    if(infoPopup) infoPopup.style.display = 'none';

                    html2canvas(document.body, {
                        backgroundColor: "black",
                        scale: 2, useCORS: true, allowTaint: true 
                    }).then(canvas => {
                        const link = document.createElement('a');
                        link.download = 'golden_message.jpg';
                        link.href = canvas.toDataURL('image/jpeg');
                        link.click();
                    }).catch(err => { 
                        console.error(err);
                        alert("캡쳐 오류 발생"); 
                    }).finally(() => { contentLayer.style.display = 'flex'; });
                });
            }

            function animateCollage() {
                pCtx.clearRect(0, 0, pCanvas.width, pCanvas.height);
                pTime += 0.05;
                particles.forEach(p => {
                    p.update(pCanvas.width, pCanvas.height);
                    p.draw(pCtx);
                });
                collageAnimationId = requestAnimationFrame(animateCollage);
            }

        });
    </script>
</body>
</html>